AI-Enhanced Microfinance Loan Management System (MLMS)
Complete Technical Documentation
Version 1.0 | Production-Ready Specification
________________


Table of Contents
1. System Architecture
2. Backend Design
3. AI/Gemini Module Design
4. Frontend Design
5. Security, Compliance & Privacy
6. Deployment Plan
________________


1. SYSTEM ARCHITECTURE
1.1 High-Level Architecture Overview
The system follows a modern 3-tier architecture with AI integration:
graph TB
    subgraph "Client Layer"
        A[Next.js Frontend<br/>TypeScript + Tailwind]
    end
    
    subgraph "API Layer"
        B[Express.js API<br/>Node.js + TypeScript]
        C[JWT Auth Middleware]
        D[Rate Limiter]
    end
    
    subgraph "Service Layer"
        E[User Service]
        F[Loan Service]
        G[Payment Service]
        H[Email Service]
        I[Risk Service]
    end
    
    subgraph "AI Layer"
        J[Gemini Client]
        K[Risk Scoring Engine]
        L[Prompt Templates]
    end
    
    subgraph "Data Layer"
        M[(MongoDB Atlas)]
    end
    
    subgraph "External Services"
        N[Stripe API]
        O[Gemini API]
        P[Email Provider<br/>SendGrid/SES]
    end
    
    subgraph "Background Jobs"
        Q[Monthly Installment Cron]
        R[Overdue Checker Cron]
        S[Default Flagging Cron]
    end
    
    A -->|HTTPS/REST| B
    B --> C
    B --> D
    C --> E
    C --> F
    C --> G
    C --> H
    C --> I
    
    I --> J
    J --> K
    K --> L
    J -->|API Calls| O
    
    E --> M
    F --> M
    G --> M
    I --> M
    
    G -->|Webhooks| N
    G -->|Checkout Sessions| N
    H -->|SMTP| P
    
    Q --> F
    Q --> H
    R --> F
    S --> F
1.2 Component Architecture
graph LR
    subgraph "Frontend Components"
        A1[Auth Pages]
        A2[User Dashboard]
        A3[Admin Dashboard]
        A4[Shared Components]
        A5[API Client Layer]
    end
    
    subgraph "Backend Modules"
        B1[Routes Layer]
        B2[Controllers]
        B3[Services]
        B4[Models]
        B5[Middlewares]
    end
    
    subgraph "AI Module"
        C1[Gemini Client]
        C2[Risk Engine]
        C3[Prompt Builder]
        C4[Response Parser]
    end
    
    subgraph "Payment Module"
        D1[Stripe Handler]
        D2[Webhook Processor]
        D3[Checkout Generator]
    end
    
    subgraph "Cron Module"
        E1[Job Scheduler]
        E2[Installment Creator]
        E3[Fine Calculator]
        E4[Email Dispatcher]
    end
    
    A5 --> B1
    B1 --> B2
    B2 --> B3
    B3 --> B4
    B3 --> C1
    B3 --> D1
    
    C1 --> C2
    C2 --> C3
    C2 --> C4
    
    D1 --> D2
    D1 --> D3
    
    E1 --> E2
    E2 --> E3
    E2 --> E4
1.3 User Registration & Approval Flow
sequenceDiagram
    participant U as User
    participant FE as Next.js Frontend
    participant API as Express API
    participant DB as MongoDB
    participant Email as Email Service
    participant Admin as Admin Portal
    
    U->>FE: Fill registration form
    FE->>API: POST /api/auth/register
    API->>API: Validate input
    API->>API: Hash password (bcrypt)
    API->>DB: Create User (status: PENDING)
    DB-->>API: User created
    API->>Email: Send "Registration Received" email
    API-->>FE: Success response
    FE-->>U: "Wait for approval" message
    
    Admin->>API: GET /api/admin/users?status=pending
    API->>DB: Query pending users
    DB-->>API: User list
    API-->>Admin: Display pending users
    
    Admin->>API: PATCH /api/admin/users/:id/approve
    API->>DB: Update user status to APPROVED
    API->>Email: Send "Account Approved" email
    API-->>Admin: Success
    
    U->>FE: Login after approval
    FE->>API: POST /api/auth/login
    API->>API: Verify credentials
    API->>API: Generate JWT tokens
    API-->>FE: Access + Refresh tokens
    FE-->>U: Redirect to dashboard
1.4 Loan Creation & AI Risk Scoring Flow
sequenceDiagram
    participant Admin as Admin
    participant API as Express API
    participant Gemini as Gemini Service
    participant AI as Google Gemini
    participant DB as MongoDB
    
    Admin->>API: POST /api/admin/risk-score/:userId
    API->>DB: Fetch user profile + history
    DB-->>API: User data
    
    API->>Gemini: buildRiskScoringContext(userData)
    Gemini->>Gemini: Anonymize data<br/>(remove CNIC, phone)
    Gemini->>Gemini: Build prompt with system message
    
    Gemini->>AI: POST to Gemini API<br/>with structured prompt
    AI-->>Gemini: JSON response with risk level
    
    Gemini->>Gemini: Parse & validate response
    Gemini-->>API: RiskProfile object
    
    API->>DB: Save/Update RiskProfile
    DB-->>API: Success
    API-->>Admin: Display risk score + reasons
    
    Admin->>API: POST /api/admin/loans/:userId
    Note over Admin,API: Include: amount, tenure,<br/>interest, start date
    
    API->>DB: Create Loan record (ACTIVE)
    API->>DB: Generate installment schedule
    DB-->>API: Loan created
    API-->>Admin: Loan details
1.5 Monthly Billing & Payment Flow
sequenceDiagram
    participant Cron as Cron Job
    participant API as Loan Service
    participant DB as MongoDB
    participant Stripe as Stripe API
    participant Email as Email Service
    participant User as User
    
    Note over Cron: Monthly: 1st of month, 2 AM
    
    Cron->>API: monthlyInstallmentsJob()
    API->>DB: Find all ACTIVE loans
    DB-->>API: Loan list
    
    loop For each loan
        API->>DB: Create Installment record<br/>(status: PENDING)
        API->>Stripe: Create checkout session
        Stripe-->>API: Session ID + URL
        API->>DB: Save session ID in installment
        API->>Email: Send payment reminder<br/>with checkout link
        Email-->>User: Email with payment link
    end
    
    User->>Stripe: Click link & pay
    Stripe->>API: POST /api/payments/stripe/webhook<br/>(checkout.session.completed)
    
    API->>API: Verify webhook signature
    API->>DB: Find installment by session ID
    API->>DB: Update installment (status: PAID)
    API->>DB: Update loan outstanding balance
    DB-->>API: Success
    
    API->>Email: Send payment confirmation
    Email-->>User: "Payment successful" email
    
    API-->>Stripe: 200 OK
1.6 Overdue & Default Handling Flow
sequenceDiagram
    participant Cron as Daily Cron
    participant API as Loan Service
    participant DB as MongoDB
    participant Email as Email Service
    participant Gemini as Risk Service
    participant Admin as Admin Dashboard
    
    Note over Cron: Daily: 3 AM
    
    Cron->>API: overdueAndFineJob()
    API->>DB: Find PENDING installments<br/>past due date
    DB-->>API: Overdue installments
    
    loop For each overdue installment
        API->>API: Check grace period (2 days)
        
        alt Within grace period
            API->>Email: Send gentle reminder
        else Past grace period
            API->>DB: Add fine amount
            API->>DB: Update status to OVERDUE
            API->>Email: Send overdue notice + fine
        end
        
        alt Past default threshold (10 days)
            API->>DB: Update status to DEFAULTED
            API->>DB: Flag loan as defaulted
            API->>Gemini: Update risk profile<br/>(increase risk score)
            API->>Email: Send default notice
            API->>Email: Notify admin of default
        end
    end
    
    Admin->>API: GET /api/admin/defaults
    API->>DB: Query defaulted loans
    DB-->>API: Defaulted loans list
    API-->>Admin: Display with AI insights
1.7 Database Entity Relationship Diagram
erDiagram
    USER ||--o{ LOAN : "has"
    USER ||--|| RISK_PROFILE : "has"
    USER ||--o{ AUDIT_LOG : "tracked by"
    
    LOAN ||--o{ INSTALLMENT : "contains"
    LOAN }o--|| USER : "belongs to"
    LOAN }o--|| ADMIN : "created by"
    
    INSTALLMENT ||--o| PAYMENT_TRANSACTION : "has"
    INSTALLMENT }o--|| LOAN : "part of"
    
    PAYMENT_TRANSACTION }o--|| INSTALLMENT : "for"
    PAYMENT_TRANSACTION }o--|| USER : "made by"
    
    EMAIL_LOG }o--|| USER : "sent to"
    
    RISK_PROFILE ||--|| USER : "for"
    
    USER {
        ObjectId _id PK
        string fullName
        string cnicHash
        string phone
        string email
        string passwordHash
        string address
        string city
        number monthlyIncome
        string employmentType
        enum status "PENDING|APPROVED|REJECTED"
        enum role "USER|ADMIN"
        date createdAt
        date updatedAt
    }
    
    RISK_PROFILE {
        ObjectId _id PK
        ObjectId userId FK
        enum riskLevel "LOW|MEDIUM|HIGH"
        array riskReasons
        number riskScore
        object geminiResponse
        date lastCalculated
        date createdAt
        date updatedAt
    }
    
    LOAN {
        ObjectId _id PK
        ObjectId userId FK
        ObjectId createdBy FK
        number principalAmount
        number interestRate
        number tenureMonths
        number outstandingBalance
        number totalRepaid
        date startDate
        date endDate
        enum status "ACTIVE|COMPLETED|DEFAULTED"
        array installmentSchedule
        date createdAt
        date updatedAt
    }
    
    INSTALLMENT {
        ObjectId _id PK
        ObjectId loanId FK
        number installmentNumber
        number amount
        number fineAmount
        date dueDate
        date paidDate
        enum status "PENDING|PAID|OVERDUE|DEFAULTED"
        string stripeSessionId
        date createdAt
        date updatedAt
    }
    
    PAYMENT_TRANSACTION {
        ObjectId _id PK
        ObjectId installmentId FK
        ObjectId userId FK
        number amount
        string currency
        string stripePaymentIntentId
        string stripeSessionId
        enum status "SUCCESS|FAILED|REFUNDED"
        object metadata
        date createdAt
    }
    
    EMAIL_LOG {
        ObjectId _id PK
        ObjectId userId FK
        string emailType
        string subject
        enum status "SENT|FAILED"
        object metadata
        date sentAt
    }
    
    AUDIT_LOG {
        ObjectId _id PK
        ObjectId userId FK
        ObjectId performedBy FK
        string action
        string entity
        object oldValue
        object newValue
        string ipAddress
        date createdAt
    }
________________


2. BACKEND DESIGN
2.1 Production-Ready Folder Structure
/
├── src/
│   ├── config/
│   │   ├── database.ts           # MongoDB connection config
│   │   ├── environment.ts        # Environment variables validation
│   │   ├── stripe.ts             # Stripe initialization
│   │   └── gemini.ts             # Gemini API configuration
│   │
│   ├── models/
│   │   ├── User.ts               # User schema
│   │   ├── Admin.ts              # Admin schema (extends User)
│   │   ├── RiskProfile.ts        # Risk profile schema
│   │   ├── Loan.ts               # Loan schema
│   │   ├── Installment.ts        # Installment schema
│   │   ├── PaymentTransaction.ts # Payment records
│   │   ├── EmailLog.ts           # Email tracking
│   │   └── AuditLog.ts           # Audit trail
│   │
│   ├── routes/
│   │   ├── index.ts              # Main router aggregator
│   │   ├── auth.routes.ts        # Authentication routes
│   │   ├── user.routes.ts        # User-facing routes
│   │   ├── admin.routes.ts       # Admin routes
│   │   ├── payment.routes.ts     # Payment & Stripe routes
│   │   └── health.routes.ts      # Health check endpoints
│   │
│   ├── controllers/
│   │   ├── auth.controller.ts    # Auth logic
│   │   ├── user.controller.ts    # User operations
│   │   ├── admin.controller.ts   # Admin operations
│   │   ├── loan.controller.ts    # Loan management
│   │   ├── payment.controller.ts # Payment handling
│   │   └── risk.controller.ts    # Risk scoring endpoints
│   │
│   ├── services/
│   │   ├── userService.ts        # User business logic
│   │   ├── loanService.ts        # Loan calculations & management
│   │   ├── paymentService.ts     # Payment processing
│   │   ├── emailService.ts       # Email dispatch
│   │   ├── riskService.ts        # Risk assessment orchestration
│   │   └── auditService.ts       # Audit logging
│   │
│   ├── ai/
│   │   ├── geminiClient.ts       # Gemini API wrapper
│   │   ├── geminiPrompts.ts      # Prompt templates
│   │   ├── riskScoringEngine.ts  # Risk calculation logic
│   │   ├── dataAnonymizer.ts     # PII removal before AI calls
│   │   └── responseParser.ts     # Parse Gemini responses safely
│   │
│   ├── stripe/
│   │   ├── webhookHandler.ts     # Webhook event processor
│   │   ├── checkoutHandler.ts    # Checkout session creation
│   │   └── signatureVerifier.ts  # Webhook signature validation
│   │
│   ├── cron/
│   │   ├── index.ts              # Cron job scheduler
│   │   ├── monthlyInstallments.ts# Monthly billing job
│   │   ├── overdueChecker.ts     # Daily overdue check
│   │   └── defaultFlagger.ts     # Default detection
│   │
│   ├── middlewares/
│   │   ├── auth.middleware.ts    # JWT verification
│   │   ├── roleCheck.middleware.ts # RBAC enforcement
│   │   ├── validation.middleware.ts # Request validation
│   │   ├── errorHandler.middleware.ts # Global error handler
│   │   ├── rateLimiter.middleware.ts # Rate limiting
│   │   └── requestLogger.middleware.ts # Request logging
│   │
│   ├── utils/
│   │   ├── logger.ts             # Winston logger setup
│   │   ├── encryption.ts         # Field-level encryption
│   │   ├── jwt.ts                # JWT token utilities
│   │   ├── calculations.ts       # Loan calculation helpers
│   │   └── dateHelpers.ts        # Date manipulation
│   │
│   ├── types/
│   │   ├── express.d.ts          # Express type extensions
│   │   ├── api.types.ts          # API request/response types
│   │   ├── gemini.types.ts       # Gemini input/output types
│   │   └── models.types.ts       # Model interface types
│   │
│   ├── validations/
│   │   ├── auth.validation.ts    # Auth schemas (Zod/Joi)
│   │   ├── user.validation.ts    # User schemas
│   │   ├── admin.validation.ts   # Admin schemas
│   │   └── loan.validation.ts    # Loan schemas
│   │
│   ├── app.ts                    # Express app setup
│   └── server.ts                 # Server entry point
│
├── tests/
│   ├── unit/
│   ├── integration/
│   └── e2e/
│
├── .env.example
├── .env.development
├── .env.production
├── .gitignore
├── package.json
├── tsconfig.json
├── nodemon.json
└── README.md
Folder Responsibilities:
* config/: Centralized configuration files for database, external APIs, and environment management
* models/: Mongoose schemas with validation, indexes, and hooks
* routes/: HTTP route definitions mapping URLs to controllers
* controllers/: Request/response handling, delegates business logic to services
* services/: Core business logic, reusable across controllers and cron jobs
* ai/: Gemini integration layer with prompt management and response parsing
* stripe/: Payment processing and webhook handling
* cron/: Scheduled background jobs for billing and monitoring
* middlewares/: Cross-cutting concerns (auth, validation, logging, errors)
* utils/: Helper functions and utilities
* types/: TypeScript type definitions and interfaces
* validations/: Input validation schemas
________________


2.2 Mongoose Models (Complete Schemas)
2.2.1 User Model
// src/models/User.ts
import mongoose, { Schema, Document } from 'mongoose';
import bcrypt from 'bcrypt';
import { encrypt, decrypt } from '../utils/encryption';


export enum UserStatus {
  PENDING = 'PENDING',
  APPROVED = 'APPROVED',
  REJECTED = 'REJECTED'
}


export enum UserRole {
  USER = 'USER',
  ADMIN = 'ADMIN'
}


export enum EmploymentType {
  SALARIED = 'SALARIED',
  SELF_EMPLOYED = 'SELF_EMPLOYED',
  BUSINESS_OWNER = 'BUSINESS_OWNER',
  DAILY_WAGE = 'DAILY_WAGE',
  UNEMPLOYED = 'UNEMPLOYED'
}


export interface IUser extends Document {
  fullName: string;
  cnicHash: string;           // Encrypted CNIC
  phone: string;
  email: string;
  passwordHash: string;
  address: string;
  city: string;
  province: string;
  monthlyIncome: number;
  employmentType: EmploymentType;
  employerName?: string;
  status: UserStatus;
  role: UserRole;
  approvedBy?: mongoose.Types.ObjectId;
  approvedAt?: Date;
  rejectionReason?: string;
  lastLoginAt?: Date;
  createdAt: Date;
  updatedAt: Date;
  
  // Virtual fields
  cnic: string;
  
  // Methods
  comparePassword(candidatePassword: string): Promise<boolean>;
  getAnonymizedProfile(): object;
}


const UserSchema = new Schema<IUser>({
  fullName: {
    type: String,
    required: [true, 'Full name is required'],
    trim: true,
    minlength: [3, 'Name must be at least 3 characters'],
    maxlength: [100, 'Name cannot exceed 100 characters']
  },
  
  cnicHash: {
    type: String,
    required: [true, 'CNIC is required'],
    unique: true,
    validate: {
      validator: function(v: string) {
        // Encrypted, so we validate before encryption in pre-save
        return v && v.length > 0;
      },
      message: 'Invalid CNIC format'
    }
  },
  
  phone: {
    type: String,
    required: [true, 'Phone is required'],
    unique: true,
    validate: {
      validator: function(v: string) {
        return /^(\+92|0)?3\d{9}$/.test(v);
      },
      message: 'Invalid Pakistani phone number'
    }
  },
  
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    trim: true,
    validate: {
      validator: function(v: string) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v);
      },
      message: 'Invalid email format'
    }
  },
  
  passwordHash: {
    type: String,
    required: [true, 'Password is required'],
    select: false  // Don't return in queries by default
  },
  
  address: {
    type: String,
    required: [true, 'Address is required'],
    maxlength: [500, 'Address too long']
  },
  
  city: {
    type: String,
    required: [true, 'City is required'],
    index: true
  },
  
  province: {
    type: String,
    required: [true, 'Province is required'],
    enum: ['Punjab', 'Sindh', 'KPK', 'Balochistan', 'Gilgit-Baltistan', 'AJK'],
    index: true
  },
  
  monthlyIncome: {
    type: Number,
    required: [true, 'Monthly income is required'],
    min: [0, 'Income cannot be negative']
  },
  
  employmentType: {
    type: String,
    required: [true, 'Employment type is required'],
    enum: Object.values(EmploymentType)
  },
  
  employerName: {
    type: String,
    trim: true
  },
  
  status: {
    type: String,
    enum: Object.values(UserStatus),
    default: UserStatus.PENDING,
    index: true
  },
  
  role: {
    type: String,
    enum: Object.values(UserRole),
    default: UserRole.USER,
    index: true
  },
  
  approvedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User'
  },
  
  approvedAt: Date,
  
  rejectionReason: String,
  
  lastLoginAt: Date
  
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});


// Indexes
UserSchema.index({ email: 1, status: 1 });
UserSchema.index({ status: 1, createdAt: -1 });
UserSchema.index({ city: 1, province: 1 });


// Virtual for decrypted CNIC (use sparingly)
UserSchema.virtual('cnic').get(function() {
  if (this.cnicHash) {
    return decrypt(this.cnicHash);
  }
  return null;
});


// Pre-save hook: Hash password
UserSchema.pre('save', async function(next) {
  if (!this.isModified('passwordHash')) return next();
  
  try {
    const salt = await bcrypt.genSalt(12);
    this.passwordHash = await bcrypt.hash(this.passwordHash, salt);
    next();
  } catch (error: any) {
    next(error);
  }
});


// Pre-save hook: Encrypt CNIC
UserSchema.pre('save', function(next) {
  if (this.isModified('cnicHash') && !this.cnicHash.startsWith('enc:')) {
    // Assuming raw CNIC is stored temporarily, encrypt it
    this.cnicHash = encrypt(this.cnicHash);
  }
  next();
});


// Method: Compare password
UserSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.passwordHash);
};


// Method: Get anonymized profile for AI
UserSchema.methods.getAnonymizedProfile = function() {
  const age = this.cnic ? calculateAgeFromCNIC(decrypt(this.cnicHash)) : null;
  
  return {
    ageBracket: age ? getAgeBracket(age) : 'unknown',
    incomeRange: getIncomeRange(this.monthlyIncome),
    employmentType: this.employmentType,
    city: this.city,
    province: this.province,
    accountAge: Math.floor((Date.now() - this.createdAt.getTime()) / (1000 * 60 * 60 * 24))
  };
};


function calculateAgeFromCNIC(cnic: string): number {
  // Pakistani CNIC format: XXXXX-XXXXXXX-X
  // Positions 7-12 contain DDMMYY
  const dateStr = cnic.substring(6, 12);
  const day = parseInt(dateStr.substring(0, 2));
  const month = parseInt(dateStr.substring(2, 4)) - 1;
  let year = parseInt(dateStr.substring(4, 6));
  
  // Adjust for century
  year += (year > 30 ? 1900 : 2000);
  
  const birthDate = new Date(year, month, day);
  const age = Math.floor((Date.now() - birthDate.getTime()) / (1000 * 60 * 60 * 24 * 365.25));
  
  return age;
}


function getAgeBracket(age: number): string {
  if (age < 25) return '18-24';
  if (age < 35) return '25-34';
  if (age < 45) return '35-44';
  if (age < 55) return '45-54';
  return '55+';
}


function getIncomeRange(income: number): string {
  if (income < 30000) return 'under-30k';
  if (income < 50000) return '30k-50k';
  if (income < 75000) return '50k-75k';
  if (income < 100000) return '75k-100k';
  return 'above-100k';
}


export default mongoose.model<IUser>('User', UserSchema);
2.2.2 Risk Profile Model
// src/models/RiskProfile.ts
import mongoose, { Schema, Document } from 'mongoose';


export enum RiskLevel {
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH'
}


export interface IRiskProfile extends Document {
  userId: mongoose.Types.ObjectId;
  riskLevel: RiskLevel;
  riskScore: number;          // 0-100
  riskReasons: string[];      // Human-readable explanations
  recommendedMaxLoan?: number;
  recommendedTenure?: number;
  defaultProbability?: number; // 0-1
  geminiResponse: {
    raw: string;
    model: string;
    tokensUsed: number;
    timestamp: Date;
  };
  lastCalculated: Date;
  version: number;             // Increments on recalculation
  createdAt: Date;
  updatedAt: Date;
}


const RiskProfileSchema = new Schema<IRiskProfile>({
  userId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    unique: true,
    index: true
  },
  
  riskLevel: {
    type: String,
    enum: Object.values(RiskLevel),
    required: true,
    index: true
  },
  
  riskScore: {
    type: Number,
    required: true,
    min: 0,
    max: 100
  },
  
  riskReasons: [{
    type: String
  }],
  
  recommendedMaxLoan: {
    type: Number,
    min: 0
  },
  
  recommendedTenure: {
    type: Number,
    min: 1,
    max: 60
  },
  
  defaultProbability: {
    type: Number,
    min: 0,
    max: 1
  },
  
  geminiResponse: {
    raw: { type: String, required: true },
    model: { type: String, required: true },
    tokensUsed: { type: Number },
    timestamp: { type: Date, default: Date.now }
  },
  
  lastCalculated: {
    type: Date,
    default: Date.now,
    index: true
  },
  
  version: {
    type: Number,
    default: 1
  }
  
}, {
  timestamps: true
});


// Compound index for analytics
RiskProfileSchema.index({ riskLevel: 1, lastCalculated: -1 });


// Pre-save hook: Increment version
RiskProfileSchema.pre('save', function(next) {
  if (this.isModified('riskScore') || this.isModified('riskLevel')) {
    this.version += 1;
    this.lastCalculated = new Date();
  }
  next();
});


export default mongoose.model<IRiskProfile>('RiskProfile', RiskProfileSchema);
2.2.3 Loan Model
// src/models/Loan.ts
import mongoose, { Schema, Document } from 'mongoose';


export enum LoanStatus {
  ACTIVE = 'ACTIVE',
  COMPLETED = 'COMPLETED',
  DEFAULTED = 'DEFAULTED',
  CANCELLED = 'CANCELLED'
}


export interface IInstallmentSchedule {
  month: number;
  dueDate: Date;
  amount: number;
}


export interface ILoan extends Document {
  userId: mongoose.Types.ObjectId;
  createdBy: mongoose.Types.ObjectId;
  principalAmount: number;
  interestRate: number;        // Annual percentage
  tenureMonths: number;
  monthlyInstallment: number;
  totalAmount: number;         // Principal + Interest
  outstandingBalance: number;
  totalRepaid: number;
  totalFines: number;
  startDate: Date;
  endDate: Date;
  status: LoanStatus;
  installmentSchedule: IInstallmentSchedule[];
  defaultedAt?: Date;
  completedAt?: Date;
  notes?: string;
  createdAt: Date;
  updatedAt: Date;
}


const LoanSchema = new Schema<ILoan>({
  userId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  
  createdBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  
  principalAmount: {
    type: Number,
    required: [true, 'Principal amount is required'],
    min: [5000, 'Minimum loan amount is PKR 5,000'],
    max: [500000, 'Maximum loan amount is PKR 500,000']
  },
  
  interestRate: {
    type: Number,
    required: [true, 'Interest rate is required'],
    min: [0, 'Interest rate cannot be negative'],
    max: [30, 'Interest rate cannot exceed 30%']
  },
  
  tenureMonths: {
    type: Number,
    required: [true, 'Tenure is required'],
    min: [3, 'Minimum tenure is 3 months'],
    max: [60, 'Maximum tenure is 60 months']
  },
  
  monthlyInstallment: {
    type: Number,
    required: true
  },
  
  totalAmount: {
    type: Number,
    required: true
  },
  
  outstandingBalance: {
    type: Number,
    required: true
  },
  
  totalRepaid: {
    type: Number,
    default: 0,
    min: 0
  },
  
  totalFines: {
    type: Number,
    default: 0,
    min: 0
  },
  
  startDate: {
    type: Date,
    required: true,
    index: true
  },
  
  endDate: {
    type: Date,
    required: true
  },
  
  status: {
    type: String,
    enum: Object.values(LoanStatus),
    default: LoanStatus.ACTIVE,
    index: true
  },
  
  installmentSchedule: [{
    month: { type: Number, required: true },
    dueDate: { type: Date, required: true },
    amount: { type: Number, required: true }
  }],
  
  defaultedAt: Date,
  
  completedAt: Date,
  
  notes: {
    type: String,
    maxlength: 1000
  }
  
}, {
  timestamps: true
});


// Indexes
LoanSchema.index({ userId: 1, status: 1 });
LoanSchema.index({ status: 1, startDate: -1 });
LoanSchema.index({ createdBy: 1, createdAt: -1 });


// Pre-save hook: Calculate loan details
LoanSchema.pre('save', function(next) {
  if (this.isNew || this.isModified('principalAmount') || this.isModified('interestRate') || this.isModified('tenureMonths')) {
    // Calculate monthly installment using reducing balance method
    const monthlyRate = this.interestRate / 12 / 100;
    const n = this.tenureMonths;
    
    if (monthlyRate === 0) {
      this.monthlyInstallment = this.principalAmount / n;
    } else {
      this.monthlyInstallment = (this.principalAmount * monthlyRate * Math.pow(1 + monthlyRate, n)) / 
                                  (Math.pow(1 + monthlyRate, n) - 1);
    }
    
    this.monthlyInstallment = Math.round(this.monthlyInstallment);
    this.totalAmount = this.monthlyInstallment * n;
    
    if (this.isNew) {
      this.outstandingBalance = this.totalAmount;
      
      // Generate installment schedule
      this.installmentSchedule = [];
      const startDate = new Date(this.startDate);
      
      for (let i = 1; i <= n; i++) {
        const dueDate = new Date(startDate);
        dueDate.setMonth(dueDate.getMonth() + i);
        
        this.installmentSchedule.push({
          month: i,
          dueDate: dueDate,
          amount: this.monthlyInstallment
        });
      }
      
      // Set end date
      const endDate = new Date(startDate);
      endDate.setMonth(endDate.getMonth() + n);
      this.endDate = endDate;
    }
  }
  
  next();
});


export default mongoose.model<ILoan>('Loan', LoanSchema);
2.2.4 Installment Model
// src/models/Installment.ts
import mongoose, { Schema, Document } from 'mongoose';


export enum InstallmentStatus {
  PENDING = 'PENDING',
  PAID = 'PAID',
  OVERDUE = 'OVERDUE',
  DEFAULTED = 'DEFAULTED',
  WAIVED = 'WAIVED'
}


export interface IInstallment extends Document {
  loanId: mongoose.Types.ObjectId;
  userId: mongoose.Types.ObjectId;
  installmentNumber: number;
  amount: number;
  fineAmount: number;
  totalDue: number;
  dueDate: Date;
  paidDate?: Date;
  status: InstallmentStatus;
  stripeSessionId?: string;
  stripePaymentIntentId?: string;
  gracePeriodDays: number;
  gracePeriodEndDate: Date;
  daysOverdue: number;
  remindersSent: number;
  lastReminderSent?: Date;
  notes?: string;
  createdAt: Date;
  updatedAt: Date;
}


const InstallmentSchema = new Schema<IInstallment>({
  loanId: {
    type: Schema.Types.ObjectId,
    ref: 'Loan',
    required: true,
    index: true
  },
  
  userId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  
  installmentNumber: {
    type: Number,
    required: true,
    min: 1
  },
  
  amount: {
    type: Number,
    required: true,
    min: 0
  },
  
  fineAmount: {
    type: Number,
    default: 0,
    min: 0
  },
  
  totalDue: {
    type: Number,
    required: true
  },
  
  dueDate: {
    type: Date,
    required: true,
    index: true
  },
  
  paidDate: Date,
  
  status: {
    type: String,
    enum: Object.values(InstallmentStatus),
    default: InstallmentStatus.PENDING,
    index: true
  },
  
  stripeSessionId: {
    type: String,
    sparse: true,
    index: true
  },
  
  stripePaymentIntentId: {
    type: String,
    sparse: true
  },
  
  gracePeriodDays: {
    type: Number,
    default: 2
  },
  
  gracePeriodEndDate: {
    type: Date,
    required: true
  },
  
  daysOverdue: {
    type: Number,
    default: 0,
    min: 0
  },
  
  remindersSent: {
    type: Number,
    default: 0
  },
  
  lastReminderSent: Date,
  
  notes: String
  
}, {
  timestamps: true
});


// Indexes
InstallmentSchema.index({ loanId: 1, installmentNumber: 1 }, { unique: true });
InstallmentSchema.index({ userId: 1, status: 1 });
InstallmentSchema.index({ status: 1, dueDate: 1 });
InstallmentSchema.index({ dueDate: 1, status: 1 });


// Pre-save hook: Calculate total due and grace period
InstallmentSchema.pre('save', function(next) {
  this.totalDue = this.amount + this.fineAmount;
  
  if (this.isNew) {
    const gracePeriodEnd = new Date(this.dueDate);
    gracePeriodEnd.setDate(gracePeriodEnd.getDate() + this.gracePeriodDays);
    this.gracePeriodEndDate = gracePeriodEnd;
  }
  
  // Calculate days overdue
  if (this.status !== InstallmentStatus.PAID && this.status !== InstallmentStatus.WAIVED) {
    const now = new Date();
    if (now > this.gracePeriodEndDate) {
      this.daysOverdue = Math.floor((now.getTime() - this.gracePeriodEndDate.getTime()) / (1000 * 60 * 60 * 24));
    }
  }
  
  next();
});


export default mongoose.model<IInstallment>('Installment', InstallmentSchema);
2.2.5 Payment Transaction Model
// src/models/PaymentTransaction.ts
import mongoose, { Schema, Document } from 'mongoose';


export enum PaymentStatus {
  PENDING = 'PENDING',
  SUCCESS = 'SUCCESS',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED',
  CANCELLED = 'CANCELLED'
}


export enum PaymentMethod {
  STRIPE_CARD = 'STRIPE_CARD',
  STRIPE_BANK = 'STRIPE_BANK',
  MANUAL = 'MANUAL',
  OTHER = 'OTHER'
}


export interface IPaymentTransaction extends Document {
  installmentId: mongoose.Types.ObjectId;
  loanId: mongoose.Types.ObjectId;
  userId: mongoose.Types.ObjectId;
  amount: number;
  currency: string;
  status: PaymentStatus;
  paymentMethod: PaymentMethod;
  stripePaymentIntentId?: string;
  stripeSessionId?: string;
  stripeChargeId?: string;
  stripeReceiptUrl?: string;
  failureReason?: string;
  refundReason?: string;
  refundedAmount?: number;
  refundedAt?: Date;
  metadata: {
    ipAddress?: string;
    userAgent?: string;
    [key: string]: any;
  };
  createdAt: Date;
  updatedAt: Date;
}


const PaymentTransactionSchema = new Schema<IPaymentTransaction>({
  installmentId: {
    type: Schema.Types.ObjectId,
    ref: 'Installment',
    required: true,
    index: true
  },
  
  loanId: {
    type: Schema.Types.ObjectId,
    ref: 'Loan',
    required: true,
    index: true
  },
  
  userId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  
  amount: {
    type: Number,
    required: true,
    min: 0
  },
  
  currency: {
    type: String,
    required: true,
    default: 'PKR',
    uppercase: true
  },
  
  status: {
    type: String,
    enum: Object.values(PaymentStatus),
    default: PaymentStatus.PENDING,
    index: true
  },
  
  paymentMethod: {
    type: String,
    enum: Object.values(PaymentMethod),
    required: true
  },
  
  stripePaymentIntentId: {
    type: String,
    sparse: true,
    index: true
  },
  
  stripeSessionId: {
    type: String,
    sparse: true,
    index: true
  },
  
  stripeChargeId: String,
  
  stripeReceiptUrl: String,
  
  failureReason: String,
  
  refundReason: String,
  
  refundedAmount: {
    type: Number,
    min: 0
  },
  
  refundedAt: Date,
  
  metadata: {
    type: Schema.Types.Mixed,
    default: {}
  }
  
}, {
  timestamps: true
});


// Indexes
PaymentTransactionSchema.index({ userId: 1, createdAt: -1 });
PaymentTransactionSchema.index({ status: 1, createdAt: -1 });
PaymentTransactionSchema.index({ stripePaymentIntentId: 1 }, { sparse: true });


export default mongoose.model<IPaymentTransaction>('PaymentTransaction', PaymentTransactionSchema);
2.2.6 Email Log Model
// src/models/EmailLog.ts
import mongoose, { Schema, Document } from 'mongoose';


export enum EmailType {
  REGISTRATION_CONFIRMATION = 'REGISTRATION_CONFIRMATION',
  ACCOUNT_APPROVED = 'ACCOUNT_APPROVED',
  ACCOUNT_REJECTED = 'ACCOUNT_REJECTED',
  LOAN_CREATED = 'LOAN_CREATED',
  INSTALLMENT_REMINDER = 'INSTALLMENT_REMINDER',
  PAYMENT_CONFIRMATION = 'PAYMENT_CONFIRMATION',
  PAYMENT_FAILED = 'PAYMENT_FAILED',
  OVERDUE_NOTICE = 'OVERDUE_NOTICE',
  DEFAULT_NOTICE = 'DEFAULT_NOTICE',
  ADMIN_ALERT = 'ADMIN_ALERT',
  PASSWORD_RESET = 'PASSWORD_RESET',
  OTHER = 'OTHER'
}


export enum EmailStatus {
  PENDING = 'PENDING',
  SENT = 'SENT',
  FAILED = 'FAILED',
  BOUNCED = 'BOUNCED'
}


export interface IEmailLog extends Document {
  userId?: mongoose.Types.ObjectId;
  recipientEmail: string;
  emailType: EmailType;
  subject: string;
  body?: string;
  status: EmailStatus;
  provider: string;
  providerMessageId?: string;
  errorMessage?: string;
  metadata: {
    loanId?: mongoose.Types.ObjectId;
    installmentId?: mongoose.Types.ObjectId;
    [key: string]: any;
  };
  sentAt?: Date;
  openedAt?: Date;
  clickedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}


const EmailLogSchema = new Schema<IEmailLog>({
  userId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    index: true
  },
  
  recipientEmail: {
    type: String,
    required: true,
    lowercase: true,
    index: true
  },
  
  emailType: {
    type: String,
    enum: Object.values(EmailType),
    required: true,
    index: true
  },
  
  subject: {
    type: String,
    required: true
  },
  
  body: String,
  
  status: {
    type: String,
    enum: Object.values(EmailStatus),
    default: EmailStatus.PENDING,
    index: true
  },
  
  provider: {
    type: String,
    required: true,
    default: 'sendgrid'
  },
  
  providerMessageId: String,
  
  errorMessage: String,
  
  metadata: {
    type: Schema.Types.Mixed,
    default: {}
  },
  
  sentAt: Date,
  
  openedAt: Date,
  
  clickedAt: Date
  
}, {
  timestamps: true
});


// Indexes
EmailLogSchema.index({ userId: 1, createdAt: -1 });
EmailLogSchema.index({ status: 1, createdAt: -1 });
EmailLogSchema.index({ emailType: 1, status: 1 });


export default mongoose.model<IEmailLog>('EmailLog', EmailLogSchema);
2.2.7 Audit Log Model
// src/models/AuditLog.ts
import mongoose, { Schema, Document } from 'mongoose';


export enum AuditAction {
  USER_REGISTERED = 'USER_REGISTERED',
  USER_APPROVED = 'USER_APPROVED',
  USER_REJECTED = 'USER_REJECTED',
  USER_LOGIN = 'USER_LOGIN',
  USER_LOGOUT = 'USER_LOGOUT',
  USER_UPDATED = 'USER_UPDATED',
  LOAN_CREATED = 'LOAN_CREATED',
  LOAN_UPDATED = 'LOAN_UPDATED',
  LOAN_DEFAULTED = 'LOAN_DEFAULTED',
  LOAN_COMPLETED = 'LOAN_COMPLETED',
  INSTALLMENT_CREATED = 'INSTALLMENT_CREATED',
  INSTALLMENT_PAID = 'INSTALLMENT_PAID',
  INSTALLMENT_OVERDUE = 'INSTALLMENT_OVERDUE',
  PAYMENT_PROCESSED = 'PAYMENT_PROCESSED',
  RISK_PROFILE_CALCULATED = 'RISK_PROFILE_CALCULATED',
  ADMIN_ACTION = 'ADMIN_ACTION'
}


export interface IAuditLog extends Document {
  userId?: mongoose.Types.ObjectId;
  performedBy?: mongoose.Types.ObjectId;
  action: AuditAction;
  entity: string;
  entityId?: mongoose.Types.ObjectId;
  oldValue?: any;
  newValue?: any;
  ipAddress?: string;
  userAgent?: string;
  metadata?: any;
  createdAt: Date;
}


const AuditLogSchema = new Schema<IAuditLog>({
  userId: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    index: true
  },
  
  performedBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
    index: true
  },
  
  action: {
    type: String,
    enum: Object.values(AuditAction),
    required: true,
    index: true
  },
  
  entity: {
    type: String,
    required: true,
    index: true
  },
  
  entityId: {
    type: Schema.Types.ObjectId,
    index: true
  },
  
  oldValue: Schema.Types.Mixed,
  
  newValue: Schema.Types.Mixed,
  
  ipAddress: String,
  
  userAgent: String,
  
  metadata: Schema.Types.Mixed
  
}, {
  timestamps: { createdAt: true, updatedAt: false }
});


// Indexes
AuditLogSchema.index({ createdAt: -1 });
AuditLogSchema.index({ userId: 1, createdAt: -1 });
AuditLogSchema.index({ performedBy: 1, createdAt: -1 });
AuditLogSchema.index({ entity: 1, entityId: 1, createdAt: -1 });


export default mongoose.model<IAuditLog>('AuditLog', AuditLogSchema);
________________


2.3 API Endpoints (Detailed Specifications)
2.3.1 Authentication Routes
// src/routes/auth.routes.ts


/**
 * POST /api/auth/register
 * Public endpoint for user registration
 */
interface RegisterRequest {
  fullName: string;
  cnic: string;              // Format: XXXXX-XXXXXXX-X
  phone: string;             // Format: +923XXXXXXXXX or 03XXXXXXXXX
  email: string;
  password: string;
  address: string;
  city: string;
  province: string;
  monthlyIncome: number;
  employmentType: 'SALARIED' | 'SELF_EMPLOYED' | 'BUSINESS_OWNER' | 'DAILY_WAGE' | 'UNEMPLOYED';
  employerName?: string;
}


interface RegisterResponse {
  success: boolean;
  message: string;
  data: {
    userId: string;
    email: string;
    status: 'PENDING';
  };
}


// Error Responses:
// 400: Validation errors (duplicate email, invalid CNIC, etc.)
// 500: Server error


/**
 * POST /api/auth/login
 * Public endpoint for user authentication
 */
interface LoginRequest {
  email: string;
  password: string;
}


interface LoginResponse {
  success: boolean;
  message: string;
  data: {
    accessToken: string;      // JWT, expires in 15 minutes
    refreshToken: string;     // JWT, expires in 7 days
    user: {
      id: string;
      fullName: string;
      email: string;
      role: 'USER' | 'ADMIN';
      status: 'PENDING' | 'APPROVED' | 'REJECTED';
    };
  };
}


// Error Responses:
// 401: Invalid credentials
// 403: Account not approved or rejected
// 500: Server error


/**
 * POST /api/auth/refresh
 * Public endpoint to refresh access token
 */
interface RefreshRequest {
  refreshToken: string;
}


interface RefreshResponse {
  success: boolean;
  data: {
    accessToken: string;
  };
}


/**
 * POST /api/auth/logout
 * Protected endpoint to invalidate tokens
 */
interface LogoutResponse {
  success: boolean;
  message: string;
}


/**
 * GET /api/auth/me
 * Protected endpoint to get current user info
 */
interface MeResponse {
  success: boolean;
  data: {
    id: string;
    fullName: string;
    email: string;
    phone: string;
    role: string;
    status: string;
    city: string;
    province: string;
    monthlyIncome: number;
    employmentType: string;
    createdAt: string;
    lastLoginAt?: string;
  };
}
2.3.2 User Routes
// src/routes/user.routes.ts


/**
 * GET /api/user/profile
 * Protected (USER role)
 */
interface GetProfileResponse {
  success: boolean;
  data: {
    id: string;
    fullName: string;
    email: string;
    phone: string;
    address: string;
    city: string;
    province: string;
    monthlyIncome: number;
    employmentType: string;
    employerName?: string;
    status: string;
    createdAt: string;
  };
}


/**
 * PUT /api/user/profile
 * Protected (USER role)
 * Allows updating limited fields
 */
interface UpdateProfileRequest {
  phone?: string;
  address?: string;
  monthlyIncome?: number;
  employerName?: string;
}


interface UpdateProfileResponse {
  success: boolean;
  message: string;
  data: GetProfileResponse['data'];
}


/**
 * GET /api/user/loan
 * Protected (USER role)
 * Get user's active loan details
 */
interface GetLoanResponse {
  success: boolean;
  data: {
    id: string;
    principalAmount: number;
    interestRate: number;
    tenureMonths: number;
    monthlyInstallment: number;
    totalAmount: number;
    outstandingBalance: number;
    totalRepaid: number;
    totalFines: number;
    startDate: string;
    endDate: string;
    status: string;
    installmentSchedule: Array<{
      month: number;
      dueDate: string;
      amount: number;
    }>;
    createdAt: string;
  } | null;
}


/**
 * GET /api/user/installments
 * Protected (USER role)
 * Query params: ?status=PENDING&page=1&limit=10
 */
interface GetInstallmentsRequest {
  status?: 'PENDING' | 'PAID' | 'OVERDUE' | 'DEFAULTED';
  page?: number;
  limit?: number;
}


interface GetInstallmentsResponse {
  success: boolean;
  data: {
    installments: Array<{
      id: string;
      installmentNumber: number;
      amount: number;
      fineAmount: number;
      totalDue: number;
      dueDate: string;
      paidDate?: string;
      status: string;
      daysOverdue: number;
      gracePeriodEndDate: string;
    }>;
    pagination: {
      currentPage: number;
      totalPages: number;
      totalCount: number;
      limit: number;
    };
  };
}


/**
 * GET /api/user/installment/:id
 * Protected (USER role)
 */
interface GetInstallmentResponse {
  success: boolean;
  data: {
    id: string;
    loanId: string;
    installmentNumber: number;
    amount: number;
    fineAmount: number;
    totalDue: number;
    dueDate: string;
    paidDate?: string;
    status: string;
    daysOverdue: number;
    gracePeriodEndDate: string;
    stripeSessionId?: string;
    paymentLink?: string;      // If unpaid
  };
}


/**
 * GET /api/user/risk-profile
 * Protected (USER role)
 */
interface GetUserRiskProfileResponse {
  success: boolean;
  data: {
    riskLevel: 'LOW' | 'MEDIUM' | 'HIGH';
    riskScore: number;
    riskReasons: string[];
    recommendedMaxLoan?: number;
    lastCalculated: string;
  } | null;
}
2.3.3 Admin Routes
// src/routes/admin.routes.ts


/**
 * GET /api/admin/users
 * Protected (ADMIN role)
 * Query params: ?status=PENDING&page=1&limit=20&search=john
 */
interface GetUsersRequest {
  status?: 'PENDING' | 'APPROVED' | 'REJECTED';
  page?: number;
  limit?: number;
  search?: string;
}


interface GetUsersResponse {
  success: boolean;
  data: {
    users: Array<{
      id: string;
      fullName: string;
      email: string;
      phone: string;
      city: string;
      province: string;
      monthlyIncome: number;
      employmentType: string;
      status: string;
      createdAt: string;
      riskLevel?: string;
    }>;
    pagination: {
      currentPage: number;
      totalPages: number;
      totalCount: number;
    };
  };
}


/**
 * PATCH /api/admin/users/:id/approve
 * Protected (ADMIN role)
 */
interface ApproveUserResponse {
  success: boolean;
  message: string;
  data: {
    userId: string;
    status: 'APPROVED';
    approvedAt: string;
  };
}


// After approval, automatically triggers risk scoring via Gemini


/**
 * PATCH /api/admin/users/:id/reject
 * Protected (ADMIN role)
 */
interface RejectUserRequest {
  reason: string;
}


interface RejectUserResponse {
  success: boolean;
  message: string;
  data: {
    userId: string;
    status: 'REJECTED';
    rejectionReason: string;
  };
}


/**
 * POST /api/admin/risk-score/:userId
 * Protected (ADMIN role)
 * Triggers AI risk assessment via Gemini
 */
interface TriggerRiskScoreRequest {
  recalculate?: boolean;      // Force recalculation even if exists
}


interface TriggerRiskScoreResponse {
  success: boolean;
  message: string;
  data: {
    userId: string;
    riskLevel: 'LOW' | 'MEDIUM' | 'HIGH';
    riskScore: number;
    riskReasons: string[];
    recommendedMaxLoan?: number;
    recommendedTenure?: number;
    defaultProbability?: number;
    calculatedAt: string;
  };
}


// Implementation calls geminiService.calculateRiskScore()


/**
 * GET /api/admin/risk-profile/:userId
 * Protected (ADMIN role)
 */
interface GetRiskProfileResponse {
  success: boolean;
  data: {
    userId: string;
    user: {
      fullName: string;
      email: string;
      city: string;
      monthlyIncome: number;
      employmentType: string;
    };
    riskProfile: {
      riskLevel: string;
      riskScore: number;
      riskReasons: string[];
      recommendedMaxLoan?: number;
      recommendedTenure?: number;
      defaultProbability?: number;
      lastCalculated: string;
      version: number;
    };
    loanHistory: Array<{
      loanId: string;
      amount: number;
      status: string;
      onTimePayments: number;
      latePayments: number;
      missedPayments: number;
    }>;
  };
}


/**
 * POST /api/admin/loans/:userId
 * Protected (ADMIN role)
 * Create and assign a loan to an approved user
 */
interface CreateLoanRequest {
  principalAmount: number;
  interestRate: number;
  tenureMonths: number;
  startDate: string;         // ISO date
  notes?: string;
}


interface CreateLoanResponse {
  success: boolean;
  message: string;
  data: {
    loanId: string;
    userId: string;
    principalAmount: number;
    interestRate: number;
    tenureMonths: number;
    monthlyInstallment: number;
    totalAmount: number;
    startDate: string;
    endDate: string;
    status: 'ACTIVE';
    installmentSchedule: Array<{
      month: number;
      dueDate: string;
      amount: number;
    }>;
  };
}


/**
 * PUT /api/admin/loans/:loanId
 * Protected (ADMIN role)
 * Update loan details (limited updates allowed)
 */
interface UpdateLoanRequest {
  notes?: string;
  status?: 'ACTIVE' | 'CANCELLED';
}


interface UpdateLoanResponse {
  success: boolean;
  message: string;
  data: {
    loanId: string;
    updatedFields: string[];
  };
}


/**
 * GET /api/admin/loans
 * Protected (ADMIN role)
 * Query params: ?status=ACTIVE&userId=xxx&page=1&limit=20
 */
interface GetLoansRequest {
  status?: 'ACTIVE' | 'COMPLETED' | 'DEFAULTED';
  userId?: string;
  page?: number;
  limit?: number;
}


interface GetLoansResponse {
  success: boolean;
  data: {
    loans: Array<{
      id: string;
      user: {
        id: string;
        fullName: string;
        email: string;
      };
      principalAmount: number;
      interestRate: number;
      tenureMonths: number;
      monthlyInstallment: number;
      outstandingBalance: number;
      totalRepaid: number;
      status: string;
      startDate: string;
      endDate: string;
      createdAt: string;
    }>;
    pagination: {
      currentPage: number;
      totalPages: number;
      totalCount: number;
    };
  };
}


/**
 * GET /api/admin/installments
 * Protected (ADMIN role)
 * Query params: ?status=OVERDUE&userId=xxx&page=1&limit=50
 */
interface GetAllInstallmentsRequest {
  status?: 'PENDING' | 'PAID' | 'OVERDUE' | 'DEFAULTED';
  userId?: string;
  loanId?: string;
  page?: number;
  limit?: number;
}


interface GetAllInstallmentsResponse {
  success: boolean;
  data: {
    installments: Array<{
      id: string;
      loan: {
        id: string;
        principalAmount: number;
      };
      user: {
        id: string;
        fullName: string;
        email: string;
        phone: string;
      };
      installmentNumber: number;
      amount: number;
      fineAmount: number;
      totalDue: number;
      dueDate: string;
      paidDate?: string;
      status: string;
      daysOverdue: number;
    }>;
    pagination: {
      currentPage: number;
      totalPages: number;
      totalCount: number;
    };
  };
}


/**
 * GET /api/admin/defaults
 * Protected (ADMIN role)
 * Get all defaulted loans with AI insights
 */
interface GetDefaultsResponse {
  success: boolean;
  data: {
    defaultedLoans: Array<{
      id: string;
      user: {
        id: string;
        fullName: string;
        email: string;
        phone: string;
        riskLevel: string;
      };
      principalAmount: number;
      outstandingBalance: number;
      totalFines: number;
      defaultedAt: string;
      daysInDefault: number;
      missedInstallments: number;
      aiPredictedDefault: boolean;
      recoveryProbability?: number;
    }>;
    summary: {
      totalDefaulted: number;
      totalOutstanding: number;
      averageDefaultTime: number;
    };
  };
}


/**
 * GET /api/admin/dashboard/stats
 * Protected (ADMIN role)
 * Main analytics dashboard data
 */
interface GetDashboardStatsResponse {
  success: boolean;
  data: {
    users: {
      total: number;
      pending: number;
      approved: number;
      rejected: number;
    };
    loans: {
      total: number;
      active: number;
      completed: number;
      defaulted: number;
      totalDisbursed: number;
      totalCollected: number;
      totalOutstanding: number;
    };
    installments: {
      pending: number;
      overdue: number;
      defaulted: number;
      dueThisMonth: number;
      expectedCollection: number;
    };
    risk: {
      lowRisk: number;
      mediumRisk: number;
      highRisk: number;
      aiPredictedDefaults: number;
    };
    recentActivity: Array<{
      type: string;
      description: string;
      timestamp: string;
    }>;
  };
}


/**
 * POST /api/admin/waive-fine/:installmentId
 * Protected (ADMIN role)
 * Waive fine for a specific installment
 */
interface WaiveFineRequest {
  reason: string;
}


interface WaiveFineResponse {
  success: boolean;
  message: string;
  data: {
    installmentId: string;
    oldFineAmount: number;
    newFineAmount: 0;
    waivedBy: string;
    reason: string;
  };
}
2.3.4 Payment Routes
// src/routes/payment.routes.ts


/**
 * POST /api/payments/create-checkout-session/:installmentId
 * Protected (USER role)
 * Creates a Stripe Checkout session for installment payment
 */
interface CreateCheckoutSessionResponse {
  success: boolean;
  data: {
    sessionId: string;
    checkoutUrl: string;
    installmentId: string;
    amount: number;
    expiresAt: string;
  };
}


// Implementation:
// 1. Fetch installment details
// 2. Verify installment belongs to authenticated user
// 3. Check installment is not already paid
// 4. Create Stripe checkout session with metadata
// 5. Save session ID to installment record
// 6. Return checkout URL


/**
 * POST /api/payments/stripe/webhook
 * Public endpoint (Stripe webhooks)
 * Raw body required for signature verification
 */
// This endpoint handles various Stripe events:
// - checkout.session.completed
// - payment_intent.succeeded
// - payment_intent.payment_failed
// - charge.refunded


interface StripeWebhookEvent {
  type: string;
  data: {
    object: any;
  };
}


// Implementation flow for checkout.session.completed:
// 1. Verify webhook signature using Stripe library
// 2. Extract session ID from event
// 3. Find installment by stripeSessionId
// 4. Create PaymentTransaction record (status: SUCCESS)
// 5. Update installment status to PAID
// 6. Update installment.paidDate
// 7. Update loan.totalRepaid and loan.outstandingBalance
// 8. If loan fully repaid, update loan.status to COMPLETED
// 9. Trigger payment confirmation email
// 10. Optionally: trigger AI to update risk score (positive behavior)
// 11. Log audit trail
// 12. Return 200 OK to Stripe


/**
 * GET /api/payments/history/:userId
 * Protected (ADMIN role) or Protected (USER role, own data)
 * Query params: ?page=1&limit=20&status=SUCCESS
 */
interface GetPaymentHistoryRequest {
  status?: 'PENDING' | 'SUCCESS' | 'FAILED' | 'REFUNDED';
  page?: number;
  limit?: number;
}


interface GetPaymentHistoryResponse {
  success: boolean;
  data: {
    payments: Array<{
      id: string;
      installmentId: string;
      loanId: string;
      amount: number;
      currency: string;
      status: string;
      paymentMethod: string;
      stripeReceiptUrl?: string;
      createdAt: string;
    }>;
    pagination: {
      currentPage: number;
      totalPages: number;
      totalCount: number;
    };
  };
}


/**
 * GET /api/payments/receipt/:transactionId
 * Protected (USER role, own data) or (ADMIN role)
 */
interface GetReceiptResponse {
  success: boolean;
  data: {
    transactionId: string;
    installmentNumber: number;
    loanId: string;
    amount: number;
    paidDate: string;
    paymentMethod: string;
    stripeReceiptUrl?: string;
    user: {
      fullName: string;
      email: string;
    };
  };
}
________________


2.4 Service Layer Implementation
2.4.1 Loan Service
// src/services/loanService.ts
import Loan, { ILoan, LoanStatus } from '../models/Loan';
import Installment, { InstallmentStatus } from '../models/Installment';
import User from '../models/User';
import { auditService } from './auditService';
import { emailService } from './emailService';
import { AuditAction } from '../models/AuditLog';


class LoanService {
  
  /**
   * Create a new loan for an approved user
   */
  async createLoan(data: {
    userId: string;
    createdBy: string;
    principalAmount: number;
    interestRate: number;
    tenureMonths: number;
    startDate: Date;
    notes?: string;
  }): Promise<ILoan> {
    // Validate user is approved
    const user = await User.findById(data.userId);
    if (!user || user.status !== 'APPROVED') {
      throw new Error('User must be approved before creating loan');
    }
    
    // Check for existing active loan
    const existingLoan = await Loan.findOne({
      userId: data.userId,
      status: LoanStatus.ACTIVE
    });
    
    if (existingLoan) {
      throw new Error('User already has an active loan');
    }
    
    // Create loan (pre-save hook calculates installments)
    const loan = await Loan.create({
      userId: data.userId,
      createdBy: data.createdBy,
      principalAmount: data.principalAmount,
      interestRate: data.interestRate,
      tenureMonths: data.tenureMonths,
      startDate: data.startDate,
      notes: data.notes
    });
    
    // Log audit
    await auditService.log({
      userId: data.userId,
      performedBy: data.createdBy,
      action: AuditAction.LOAN_CREATED,
      entity: 'Loan',
      entityId: loan._id,
      newValue: loan.toObject()
    });
    
    // Send loan creation email
    await emailService.sendLoanCreatedEmail(user.email, {
      userName: user.fullName,
      loanAmount: loan.principalAmount,
      tenure: loan.tenureMonths,
      monthlyInstallment: loan.monthlyInstallment,
      startDate: loan.startDate
    });
    
    return loan;
  }
  
  /**
   * Get loan details with installments
   */
  async getLoanWithInstallments(loanId: string): Promise<{
    loan: ILoan;
    installments: any[];
  }> {
    const loan = await Loan.findById(loanId).populate('userId', 'fullName email');
    if (!loan) {
      throw new Error('Loan not found');
    }
    
    const installments = await Installment.find({ loanId })
      .sort({ installmentNumber: 1 });
    
    return { loan, installments };
  }
  
  /**
   * Update loan outstanding balance after payment
   */
  async updateLoanBalance(loanId: string, paidAmount: number): Promise<ILoan> {
    const loan = await Loan.findById(loanId);
    if (!loan) {
      throw new Error('Loan not found');
    }
    
    loan.totalRepaid += paidAmount;
    loan.outstandingBalance -= paidAmount;
    
    // Check if loan is fully paid
    if (loan.outstandingBalance <= 0) {
      loan.status = LoanStatus.COMPLETED;
      loan.completedAt = new Date();
      
      await auditService.log({
        userId: loan.userId,
        action: AuditAction.LOAN_COMPLETED,
        entity: 'Loan',
        entityId: loan._id,
        newValue: { status: LoanStatus.COMPLETED }
      });
    }
    
    await loan.save();
    return loan;
  }
  
  /**
   * Mark loan as defaulted
   */
  async markLoanAsDefaulted(loanId: string): Promise<ILoan> {
    const loan = await Loan.findById(loanId);
    if (!loan) {
      throw new Error('Loan not found');
    }
    
    loan.status = LoanStatus.DEFAULTED;
    loan.defaultedAt = new Date();
    await loan.save();
    
    await auditService.log({
      userId: loan.userId,
      action: AuditAction.LOAN_DEFAULTED,
      entity: 'Loan',
      entityId: loan._id,
      newValue: { status: LoanStatus.DEFAULTED }
    });
    
    return loan;
  }
  
  /**
   * Get analytics for admin dashboard
   */
  async getDashboardAnalytics() {
    const [
      totalLoans,
      activeLoans,
      completedLoans,
      defaultedLoans,
      disbursedAmount,
      collectedAmount,
      outstandingAmount
    ] = await Promise.all([
      Loan.countDocuments(),
      Loan.countDocuments({ status: LoanStatus.ACTIVE }),
      Loan.countDocuments({ status: LoanStatus.COMPLETED }),
      Loan.countDocuments({ status: LoanStatus.DEFAULTED }),
      Loan.aggregate([
        { $group: { _id: null, total: { $sum: '$principalAmount' } } }
      ]),
      Loan.aggregate([
        { $group: { _id: null, total: { $sum: '$totalRepaid' } } }
      ]),
      Loan.aggregate([
        { $match: { status: LoanStatus.ACTIVE } },
        { $group: { _id: null, total: { $sum: '$outstandingBalance' } } }
      ])
    ]);
    
    return {
      total: totalLoans,
      active: activeLoans,
      completed: completedLoans,
      defaulted: defaultedLoans,
      totalDisbursed: disbursedAmount[0]?.total || 0,
      totalCollected: collectedAmount[0]?.total || 0,
      totalOutstanding: outstandingAmount[0]?.total || 0
    };
  }
}


export const loanService = new LoanService();
2.4.2 Payment Service
// src/services/paymentService.ts
import Stripe from 'stripe';
import Installment, { InstallmentStatus } from '../models/Installment';
import PaymentTransaction, { PaymentStatus, PaymentMethod } from '../models/PaymentTransaction';
import { loanService } from './loanService';
import { emailService } from './emailService';
import { auditService } from './auditService';
import { AuditAction } from '../models/AuditLog';
import { config } from '../config/environment';


const stripe = new Stripe(config.stripe.secretKey, {
  apiVersion: '2023-10-16'
});


class PaymentService {
  
  /**
   * Create Stripe Checkout session for installment payment
   */
  async createCheckoutSession(installmentId: string, userId: string): Promise<{
    sessionId: string;
    url: string;
  }> {
    const installment = await Installment.findById(installmentId)
      .populate('userId', 'fullName email')
      .populate('loanId');
    
    if (!installment) {
      throw new Error('Installment not found');
    }
    
    if (installment.userId._id.toString() !== userId) {
      throw new Error('Unauthorized');
    }
    
    if (installment.status === InstallmentStatus.PAID) {
      throw new Error('Installment already paid');
    }
    
    // Create Stripe session
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      mode: 'payment',
      customer_email: installment.userId.email,
      line_items: [
        {
          price_data: {
            currency: 'pkr',
            product_data: {
              name: `Loan Installment #${installment.installmentNumber}`,
              description: `Loan ID: ${installment.loanId._id}`
            },
            unit_amount: Math.round(installment.totalDue * 100) // Convert to paisa
          },
          quantity: 1
        }
      ],
      metadata: {
        installmentId: installment._id.toString(),
        loanId: installment.loanId._id.toString(),
        userId: userId,
        installmentNumber: installment.installmentNumber.toString()
      },
      success_url: `${config.frontend.url}/dashboard/installments?payment=success&session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${config.frontend.url}/dashboard/installments?payment=cancelled`,
      expires_at: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24 hours
    });
    
    // Save session ID to installment
    installment.stripeSessionId = session.id;
    await installment.save();
    
    return {
      sessionId: session.id,
      url: session.url!
    };
  }
  
  /**
   * Process successful payment from webhook
   */
  async processSuccessfulPayment(session: Stripe.Checkout.Session): Promise<void> {
    const installmentId = session.metadata?.installmentId;
    if (!installmentId) {
      throw new Error('Installment ID not found in session metadata');
    }
    
    const installment = await Installment.findById(installmentId)
      .populate('userId', 'fullName email');
    
    if (!installment) {
      throw new Error('Installment not found');
    }
    
    // Check if already processed
    if (installment.status === InstallmentStatus.PAID) {
      console.log(`Installment ${installmentId} already processed`);
      return;
    }
    
    // Create payment transaction record
    const transaction = await PaymentTransaction.create({
      installmentId: installment._id,
      loanId: installment.loanId,
      userId: installment.userId._id,
      amount: installment.totalDue,
      currency: 'PKR',
      status: PaymentStatus.SUCCESS,
      paymentMethod: PaymentMethod.STRIPE_CARD,
      stripeSessionId: session.id,
      stripePaymentIntentId: session.payment_intent as string,
      metadata: {
        customerEmail: session.customer_email,
        amountTotal: session.amount_total
      }
    });
    
    // Update installment
    installment.status = InstallmentStatus.PAID;
    installment.paidDate = new Date();
    installment.stripePaymentIntentId = session.payment_intent as string;
    await installment.save();
    
    // Update loan balance
    await loanService.updateLoanBalance(
      installment.loanId.toString(),
      installment.totalDue
    );
    
    // Log audit
    await auditService.log({
      userId: installment.userId._id,
      action: AuditAction.INSTALLMENT_PAID,
      entity: 'Installment',
      entityId: installment._id,
      newValue: {
        status: InstallmentStatus.PAID,
        paidDate: installment.paidDate,
        amount: installment.totalDue
      }
    });
    
    // Send confirmation email
    await emailService.sendPaymentConfirmationEmail(installment.userId.email, {
      userName: installment.userId.fullName,
      installmentNumber: installment.installmentNumber,
      amount: installment.amount,
      fineAmount: installment.fineAmount,
      totalPaid: installment.totalDue,
      paidDate: installment.paidDate!,
      transactionId: transaction._id.toString()
    });
  }
  
  /**
   * Process failed payment
   */
  async processFailedPayment(paymentIntent: Stripe.PaymentIntent): Promise<void> {
    const metadata = paymentIntent.metadata;
    const installmentId = metadata?.installmentId;
    
    if (!installmentId) {
      return;
    }
    
    const installment = await Installment.findById(installmentId)
      .populate('userId', 'email fullName');
    
    if (!installment) {
      return;
    }
    
    // Create failed transaction record
    await PaymentTransaction.create({
      installmentId: installment._id,
      loanId: installment.loanId,
      userId: installment.userId._id,
      amount: installment.totalDue,
      currency: 'PKR',
      status: PaymentStatus.FAILED,
      paymentMethod: PaymentMethod.STRIPE_CARD,
      stripePaymentIntentId: paymentIntent.id,
      failureReason: paymentIntent.last_payment_error?.message || 'Unknown error'
    });
    
    // Send failure email
    await emailService.sendPaymentFailedEmail(installment.userId.email, {
      userName: installment.userId.fullName,
      installmentNumber: installment.installmentNumber,
      amount: installment.totalDue,
      reason: paymentIntent.last_payment_error?.message
    });
  }
  
  /**
   * Get payment history for user
   */
  async getPaymentHistory(userId: string, filters: {
    status?: PaymentStatus;
    page?: number;
    limit?: number;
  }) {
    const page = filters.page || 1;
    const limit = filters.limit || 20;
    const skip = (page - 1) * limit;
    
    const query: any = { userId };
    if (filters.status) {
      query.status = filters.status;
    }
    
    const [payments, total] = await Promise.all([
      PaymentTransaction.find(query)
        .populate('installmentId', 'installmentNumber dueDate')
        .populate('loanId', 'principalAmount')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit),
      PaymentTransaction.countDocuments(query)
    ]);
    
    return {
      payments,
      pagination: {
        currentPage: page,
        totalPages: Math.ceil(total / limit),
        totalCount: total,
        limit
      }
    };
  }
}


export const paymentService = new PaymentService();
2.4.3 Email Service
// src/services/emailService.ts
import nodemailer from 'nodemailer';
import sgMail from '@sendgrid/mail';
import EmailLog, { EmailType, EmailStatus } from '../models/EmailLog';
import { config } from '../config/environment';


// Configure SendGrid
sgMail.setApiKey(config.email.sendgridApiKey);


class EmailService {
  private provider: string;
  
  constructor() {
    this.provider = config.email.provider || 'sendgrid';
  }
  
  /**
   * Core email sending function
   */
  private async sendEmail(params: {
    to: string;
    subject: string;
    html: string;
    userId?: string;
    emailType: EmailType;
    metadata?: any;
  }): Promise<void> {
    try {
      let messageId: string | undefined;
      
      if (this.provider === 'sendgrid') {
        const response = await sgMail.send({
          to: params.to,
          from: config.email.fromAddress,
          subject: params.subject,
          html: params.html
        });
        messageId = response[0].headers['x-message-id'];
      } else {
        // Fallback to Nodemailer (SMTP)
        const transporter = nodemailer.createTransporter(config.email.smtp);
        const info = await transporter.sendMail({
          from: config.email.fromAddress,
          to: params.to,
          subject: params.subject,
          html: params.html
        });
        messageId = info.messageId;
      }
      
      // Log email
      await EmailLog.create({
        userId: params.userId,
        recipientEmail: params.to,
        emailType: params.emailType,
        subject: params.subject,
        body: params.html,
        status: EmailStatus.SENT,
        provider: this.provider,
        providerMessageId: messageId,
        metadata: params.metadata,
        sentAt: new Date()
      });
      
    } catch (error: any) {
      // Log failed email
      await EmailLog.create({
        userId: params.userId,
        recipientEmail: params.to,
        emailType: params.emailType,
        subject: params.subject,
        body: params.html,
        status: EmailStatus.FAILED,
        provider: this.provider,
        errorMessage: error.message,
        metadata: params.metadata
      });
      
      console.error('Email sending failed:', error);
      throw error;
    }
  }
  
  /**
   * Send registration confirmation
   */
  async sendRegistrationConfirmation(email: string, data: {
    userName: string;
  }): Promise<void> {
    const html = `
      <!DOCTYPE html>
      <html>
      <head>
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: #4F46E5; color: white; padding: 20px; text-align: center; }
          .content { padding: 20px; background: #f9fafb; }
          .footer { padding: 20px; text-align: center; font-size: 12px; color: #666; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>Registration Received</h1>
          </div>
          <div class="content">
            <p>Dear ${data.userName},</p>
            <p>Thank you for registering with our Microfinance Loan Management System.</p>
            <p>Your application is currently under review by our admin team. You will receive an email notification once your account has been approved.</p>
            <p>This usually takes 1-2 business days.</p>
            <p>If you have any questions, please don't hesitate to contact us.</p>
          </div>
          <div class="footer">
            <p>&copy; 2025 Microfinance Loan Management System. All rights reserved.</p>
          </div>
        </div>
      </body>
      </html>
    `;
    
    await this.sendEmail({
      to: email,
      subject: 'Registration Received - Pending Approval',
      html,
      emailType: EmailType.REGISTRATION_CONFIRMATION,
      metadata: { userName: data.userName }
    });
  }
  
  /**
   * Send account approved notification
   */
  async sendAccountApproved(email: string, data: {
    userName: string;
    loginUrl: string;
  }): Promise<void> {
    const html = `
      <!DOCTYPE html>
      <html>
      <head>
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: #10B981; color: white; padding: 20px; text-align: center; }
          .content { padding: 20px; background: #f9fafb; }
          .button { display: inline-block; padding: 12px 24px; background: #4F46E5; color: white; text-decoration: none; border-radius: 5px; margin: 20px 0; }
          .footer { padding: 20px; text-align: center; font-size: 12px; color: #666; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>🎉 Account Approved!</h1>
          </div>
          <div class="content">
            <p>Dear ${data.userName},</p>
            <p>Great news! Your account has been approved.</p>
            <p>You can now log in to your dashboard and explore loan options tailored to your profile.</p>
            <p><a href="${data.loginUrl}" class="button">Login to Dashboard</a></p>
            <p>Our team has assessed your profile and you're eligible for microfinance loans. Check your risk profile and loan recommendations in your dashboard.</p>
          </div>
          <div class="footer">
            <p>&copy; 2025 Microfinance Loan Management System. All rights reserved.</p>
          </div>
        </div>
      </body>
      </html>
    `;
    
    await this.sendEmail({
      to: email,
      subject: '✅ Your Account Has Been Approved',
      html,
      emailType: EmailType.ACCOUNT_APPROVED,
      metadata: { userName: data.userName }
    });
  }
  
  /**
   * Send loan created notification
   */
  async sendLoanCreatedEmail(email: string, data: {
    userName: string;
    loanAmount: number;
    tenure: number;
    monthlyInstallment: number;
    startDate: Date;
  }): Promise<void> {
    const html = `
      <!DOCTYPE html>
      <html>
      <body>
        <div class="container">
          <h2>Loan Created Successfully</h2>
          <p>Dear ${data.userName},</p>
          <p>Your loan has been approved and created with the following details:</p>
          <table style="width: 100%; border-collapse: collapse;">
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Loan Amount:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">PKR ${data.loanAmount.toLocaleString()}</td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Tenure:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">${data.tenure} months</td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Monthly Installment:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">PKR ${data.monthlyInstallment.toLocaleString()}</td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Start Date:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">${data.startDate.toLocaleDateString()}</td></tr>
          </table>
          <p>Your first installment will be due next month. You'll receive a payment reminder with a secure payment link.</p>
        </div>
      </body>
      </html>
    `;
    
    await this.sendEmail({
      to: email,
      subject: 'Loan Approved - Disbursement Details',
      html,
      emailType: EmailType.LOAN_CREATED,
      metadata: data
    });
  }
  
  /**
   * Send monthly installment reminder
   */
  async sendInstallmentReminder(email: string, data: {
    userName: string;
    installmentNumber: number;
    amount: number;
    fineAmount: number;
    totalDue: number;
    dueDate: Date;
    paymentLink: string;
  }): Promise<void> {
    const html = `
      <!DOCTYPE html>
      <html>
      <body>
        <div class="container">
          <h2>Installment Payment Reminder</h2>
          <p>Dear ${data.userName},</p>
          <p>This is a reminder that your installment #${data.installmentNumber} is due on ${data.dueDate.toLocaleDateString()}.</p>
          <table style="width: 100%; border-collapse: collapse;">
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Installment Amount:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">PKR ${data.amount.toLocaleString()}</td></tr>
            ${data.fineAmount > 0 ? `<tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Fine Amount:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">PKR ${data.fineAmount.toLocaleString()}</td></tr>` : ''}
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Total Due:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">PKR ${data.totalDue.toLocaleString()}
</td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Due Date:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">${data.dueDate.toLocaleDateString()}</td></tr>
          </table>
          <p style="margin: 30px 0;">
            <a href="${data.paymentLink}" style="display: inline-block; padding: 15px 30px; background: #4F46E5; color: white; text-decoration: none; border-radius: 5px; font-weight: bold;">Pay Now</a>
          </p>
          <p><small>Click the button above to make a secure payment via Stripe. The link is valid for 24 hours.</small></p>
        </div>
      </body>
      </html>
    `;
    
    await this.sendEmail({
      to: email,
      subject: `Payment Reminder - Installment #${data.installmentNumber} Due`,
      html,
      emailType: EmailType.INSTALLMENT_REMINDER,
      metadata: data
    });
  }
  
  /**
   * Send payment confirmation
   */
  async sendPaymentConfirmationEmail(email: string, data: {
    userName: string;
    installmentNumber: number;
    amount: number;
    fineAmount: number;
    totalPaid: number;
    paidDate: Date;
    transactionId: string;
  }): Promise<void> {
    const html = `
      <!DOCTYPE html>
      <html>
      <body>
        <div class="container">
          <div style="background: #10B981; color: white; padding: 20px; text-align: center; border-radius: 5px;">
            <h2>✅ Payment Successful</h2>
          </div>
          <p>Dear ${data.userName},</p>
          <p>Your payment has been successfully processed. Thank you for your timely payment!</p>
          <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Installment Number:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">#${data.installmentNumber}</td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Installment Amount:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">PKR ${data.amount.toLocaleString()}</td></tr>
            ${data.fineAmount > 0 ? `<tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Fine Amount:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">PKR ${data.fineAmount.toLocaleString()}</td></tr>` : ''}
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Total Paid:</strong></td><td style="padding: 10px; border: 1px solid #ddd;"><strong>PKR ${data.totalPaid.toLocaleString()}</strong></td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Payment Date:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">${data.paidDate.toLocaleDateString()}</td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Transaction ID:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">${data.transactionId}</td></tr>
          </table>
          <p>Your payment receipt is available in your dashboard. Keep this email for your records.</p>
        </div>
      </body>
      </html>
    `;
    
    await this.sendEmail({
      to: email,
      subject: '✅ Payment Received - Receipt',
      html,
      emailType: EmailType.PAYMENT_CONFIRMATION,
      metadata: data
    });
  }
  
  /**
   * Send overdue notice
   */
  async sendOverdueNotice(email: string, data: {
    userName: string;
    installmentNumber: number;
    daysOverdue: number;
    originalAmount: number;
    fineAmount: number;
    totalDue: number;
    paymentLink: string;
  }): Promise<void> {
    const html = `
      <!DOCTYPE html>
      <html>
      <body>
        <div class="container">
          <div style="background: #EF4444; color: white; padding: 20px; text-align: center; border-radius: 5px;">
            <h2>⚠️ Overdue Payment Notice</h2>
          </div>
          <p>Dear ${data.userName},</p>
          <p><strong>Your installment #${data.installmentNumber} is now ${data.daysOverdue} days overdue.</strong></p>
          <p>The grace period has expired and a late payment fine has been added to your account.</p>
          <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Original Amount:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">PKR ${data.originalAmount.toLocaleString()}</td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Late Payment Fine:</strong></td><td style="padding: 10px; border: 1px solid #ddd; color: #EF4444;">PKR ${data.fineAmount.toLocaleString()}</td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Total Amount Due:</strong></td><td style="padding: 10px; border: 1px solid #ddd;"><strong>PKR ${data.totalDue.toLocaleString()}</strong></td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Days Overdue:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">${data.daysOverdue} days</td></tr>
          </table>
          <p style="color: #EF4444;"><strong>Important:</strong> Continued non-payment may result in your loan being marked as defaulted, which will negatively impact your credit profile and eligibility for future loans.</p>
          <p style="margin: 30px 0;">
            <a href="${data.paymentLink}" style="display: inline-block; padding: 15px 30px; background: #EF4444; color: white; text-decoration: none; border-radius: 5px; font-weight: bold;">Pay Now to Avoid Default</a>
          </p>
          <p>Please make payment immediately to avoid further penalties. If you're facing financial difficulties, please contact us to discuss payment arrangements.</p>
        </div>
      </body>
      </html>
    `;
    
    await this.sendEmail({
      to: email,
      subject: `⚠️ URGENT: Payment Overdue - Installment #${data.installmentNumber}`,
      html,
      emailType: EmailType.OVERDUE_NOTICE,
      metadata: data
    });
  }
  
  /**
   * Send default notice
   */
  async sendDefaultNotice(email: string, data: {
    userName: string;
    installmentNumber: number;
    daysOverdue: number;
    totalDue: number;
    outstandingBalance: number;
  }): Promise<void> {
    const html = `
      <!DOCTYPE html>
      <html>
      <body>
        <div class="container">
          <div style="background: #7C3AED; color: white; padding: 20px; text-align: center; border-radius: 5px;">
            <h2>🚨 Loan Default Notice</h2>
          </div>
          <p>Dear ${data.userName},</p>
          <p><strong>Your loan has been marked as DEFAULTED due to non-payment.</strong></p>
          <p>Installment #${data.installmentNumber} has been overdue for ${data.daysOverdue} days without payment, exceeding our default threshold.</p>
          <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Overdue Installment:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">PKR ${data.totalDue.toLocaleString()}</td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Total Outstanding Balance:</strong></td><td style="padding: 10px; border: 1px solid #ddd;"><strong>PKR ${data.outstandingBalance.toLocaleString()}</strong></td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Days Overdue:</strong></td><td style="padding: 10px; border: 1px solid #ddd;">${data.daysOverdue} days</td></tr>
            <tr><td style="padding: 10px; border: 1px solid #ddd;"><strong>Status:</strong></td><td style="padding: 10px; border: 1px solid #ddd; color: #EF4444;"><strong>DEFAULTED</strong></td></tr>
          </table>
          <p><strong>Consequences of Default:</strong></p>
          <ul>
            <li>Your credit profile has been severely downgraded</li>
            <li>You are no longer eligible for new loans</li>
            <li>Legal action may be initiated for debt recovery</li>
            <li>Your default status will be reported to credit bureaus</li>
          </ul>
          <p>We strongly urge you to contact our office immediately to discuss settlement options and avoid further legal action.</p>
          <p><strong>Contact Us:</strong> support@mlms.com | +92-XXX-XXXXXXX</p>
        </div>
      </body>
      </html>
    `;
    
    await this.sendEmail({
      to: email,
      subject: '🚨 CRITICAL: Loan Default Notice - Immediate Action Required',
      html,
      emailType: EmailType.DEFAULT_NOTICE,
      metadata: data
    });
  }
  
  /**
   * Send payment failed notification
   */
  async sendPaymentFailedEmail(email: string, data: {
    userName: string;
    installmentNumber: number;
    amount: number;
    reason?: string;
  }): Promise<void> {
    const html = `
      <!DOCTYPE html>
      <html>
      <body>
        <div class="container">
          <div style="background: #F59E0B; color: white; padding: 20px; text-align: center; border-radius: 5px;">
            <h2>❌ Payment Failed</h2>
          </div>
          <p>Dear ${data.userName},</p>
          <p>Unfortunately, your payment for installment #${data.installmentNumber} could not be processed.</p>
          <p><strong>Amount:</strong> PKR ${data.amount.toLocaleString()}</p>
          ${data.reason ? `<p><strong>Reason:</strong> ${data.reason}</p>` : ''}
          <p>Please check your payment method and try again. Common reasons for payment failure include:</p>
          <ul>
            <li>Insufficient funds</li>
            <li>Expired card</li>
            <li>Incorrect card details</li>
            <li>Bank declining the transaction</li>
          </ul>
          <p>Please log in to your dashboard to retry payment or use a different payment method.</p>
        </div>
      </body>
      </html>
    `;
    
    await this.sendEmail({
      to: email,
      subject: `Payment Failed - Installment #${data.installmentNumber}`,
      html,
      emailType: EmailType.PAYMENT_FAILED,
      metadata: data
    });
  }
}


export const emailService = new EmailService();
________________


3. AI/GEMINI MODULE DESIGN
3.1 Gemini Client Setup
// src/ai/geminiClient.ts
import { GoogleGenerativeAI } from '@google/generative-ai';
import { config } from '../config/environment';
import logger from '../utils/logger';


class GeminiClient {
  private genAI: GoogleGenerativeAI;
  private model: any;
  private readonly MODEL_NAME = 'gemini-1.5-flash';
  private readonly MAX_RETRIES = 3;
  private readonly TIMEOUT_MS = 30000;
  
  constructor() {
    this.genAI = new GoogleGenerativeAI(config.gemini.apiKey);
    this.model = this.genAI.getGenerativeModel({ model: this.MODEL_NAME });
  }
  
  /**
   * Generate content with retry logic
   */
  async generateContent(prompt: string, retries = 0): Promise<{
    text: string;
    tokensUsed?: number;
  }> {
    try {
      logger.info('Calling Gemini API', { modelName: this.MODEL_NAME });
      
      const result = await Promise.race([
        this.model.generateContent(prompt),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Gemini API timeout')), this.TIMEOUT_MS)
        )
      ]);
      
      const response = await (result as any).response;
      const text = response.text();
      
      logger.info('Gemini API response received', { 
        textLength: text.length,
        tokensUsed: response.usageMetadata?.totalTokenCount
      });
      
      return {
        text,
        tokensUsed: response.usageMetadata?.totalTokenCount
      };
      
    } catch (error: any) {
      logger.error('Gemini API error', { error: error.message, retries });
      
      // Retry logic
      if (retries < this.MAX_RETRIES) {
        const backoffMs = Math.pow(2, retries) * 1000;
        logger.info(`Retrying Gemini API call in ${backoffMs}ms`);
        await new Promise(resolve => setTimeout(resolve, backoffMs));
        return this.generateContent(prompt, retries + 1);
      }
      
      throw new Error(`Gemini API failed after ${this.MAX_RETRIES} retries: ${error.message}`);
    }
  }
  
  /**
   * Generate structured JSON response
   */
  async generateStructuredContent<T>(prompt: string): Promise<T> {
    const response = await this.generateContent(prompt);
    
    try {
      // Remove markdown code blocks if present
      let cleanText = response.text.trim();
      cleanText = cleanText.replace(/```json\n?/g, '').replace(/```\n?/g, '');
      
      const parsed = JSON.parse(cleanText);
      return parsed as T;
      
    } catch (error) {
      logger.error('Failed to parse Gemini JSON response', { 
        response: response.text,
        error 
      });
      throw new Error('Invalid JSON response from Gemini');
    }
  }
  
  /**
   * Health check
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.generateContent('Respond with "OK"');
      return true;
    } catch {
      return false;
    }
  }
}


export const geminiClient = new GeminiClient();
3.2 Prompt Templates
// src/ai/geminiPrompts.ts


export interface RiskScoringInput {
  ageBracket: string;
  incomeRange: string;
  employmentType: string;
  city: string;
  province: string;
  accountAge: number;
  requestedAmount?: number;
  requestedTenure?: number;
  loanHistory?: {
    totalLoans: number;
    completedLoans: number;
    defaultedLoans: number;
    onTimePayments: number;
    latePayments: number;
    missedPayments: number;
    averagePaymentDelay: number;
  };
}


export interface RiskScoringOutput {
  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH';
  riskScore: number;
  riskReasons: string[];
  recommendedMaxLoan?: number;
  recommendedTenure?: number;
  defaultProbability?: number;
}


export class GeminiPrompts {
  
  /**
   * System prompt for risk scoring
   */
  static readonly RISK_SCORING_SYSTEM_PROMPT = `You are a conservative credit risk advisor for a Pakistani microfinance institution.


Your role is to assess loan applicants and provide risk scores based on their financial profile and history.


GUIDELINES:
- You must be risk-averse and prioritize the financial safety of the institution
- Consider Pakistani economic context: average income, inflation, employment stability
- Pakistani microfinance typical loan range: PKR 5,000 - PKR 500,000
- Typical monthly income ranges: Under 30k (low), 30-50k (lower-middle), 50-75k (middle), 75-100k (upper-middle), 100k+ (high)
- Employment stability matters: Salaried (most stable) > Business Owner > Self-Employed > Daily Wage (least stable)
- Shorter tenure (3-12 months) is safer than longer tenure
- Payment history is the strongest predictor of future behavior


RISK LEVELS:
- LOW: Strong income, stable employment, good payment history, low debt-to-income ratio
- MEDIUM: Moderate income, adequate employment stability, some payment delays but no defaults
- HIGH: Low/unstable income, poor employment stability, history of defaults or significant delays


You must respond ONLY with valid JSON in the exact format specified. No preamble, no markdown, no explanations outside the JSON.`;


  /**
   * Build risk scoring prompt
   */
  static buildRiskScoringPrompt(input: RiskScoringInput): string {
    const hasHistory = input.loanHistory && input.loanHistory.totalLoans > 0;
    
    const prompt = `${this.RISK_SCORING_SYSTEM_PROMPT}


APPLICANT PROFILE:
- Age Bracket: ${input.ageBracket}
- Income Range: ${input.incomeRange}
- Employment Type: ${input.employmentType}
- Location: ${input.city}, ${input.province}
- Account Age: ${input.accountAge} days


${hasHistory ? `
LOAN HISTORY:
- Total Loans: ${input.loanHistory!.totalLoans}
- Completed Loans: ${input.loanHistory!.completedLoans}
- Defaulted Loans: ${input.loanHistory!.defaultedLoans}
- On-Time Payments: ${input.loanHistory!.onTimePayments}
- Late Payments: ${input.loanHistory!.latePayments}
- Missed Payments: ${input.loanHistory!.missedPayments}
- Average Payment Delay: ${input.loanHistory!.averagePaymentDelay} days
` : `
LOAN HISTORY:
- This is a new applicant with no prior loan history
`}


${input.requestedAmount ? `
LOAN REQUEST:
- Requested Amount: PKR ${input.requestedAmount.toLocaleString()}
- Requested Tenure: ${input.requestedTenure} months
` : ''}


TASK:
Assess this applicant and provide a comprehensive risk evaluation.


RESPONSE FORMAT (JSON only, no markdown):
{
  "riskLevel": "LOW" | "MEDIUM" | "HIGH",
  "riskScore": <number 0-100, where 0 is lowest risk>,
  "riskReasons": [
    "<specific reason 1>",
    "<specific reason 2>",
    "<specific reason 3>"
  ],
  "recommendedMaxLoan": <number in PKR, safe loan amount>,
  "recommendedTenure": <number in months, safe tenure>,
  "defaultProbability": <number 0-1, estimated probability of default>
}


Provide your assessment now:`;


    return prompt;
  }
  
  /**
   * Build default prediction prompt
   */
  static buildDefaultPredictionPrompt(input: {
    currentLoan: {
      principalAmount: number;
      outstandingBalance: number;
      monthsRemaining: number;
    };
    paymentBehavior: {
      totalInstallments: number;
      paidInstallments: number;
      overdueInstallments: number;
      averageDelayDays: number;
    };
    financialProfile: RiskScoringInput;
  }): string {
    return `${this.RISK_SCORING_SYSTEM_PROMPT}


CURRENT LOAN:
- Principal Amount: PKR ${input.currentLoan.principalAmount.toLocaleString()}
- Outstanding Balance: PKR ${input.currentLoan.outstandingBalance.toLocaleString()}
- Months Remaining: ${input.currentLoan.monthsRemaining}


PAYMENT BEHAVIOR:
- Total Installments: ${input.paymentBehavior.totalInstallments}
- Paid On Time: ${input.paymentBehavior.paidInstallments}
- Currently Overdue: ${input.paymentBehavior.overdueInstallments}
- Average Payment Delay: ${input.paymentBehavior.averageDelayDays} days


APPLICANT PROFILE:
- Age Bracket: ${input.financialProfile.ageBracket}
- Income Range: ${input.financialProfile.incomeRange}
- Employment Type: ${input.financialProfile.employmentType}


TASK:
Based on the payment behavior and current financial situation, predict the likelihood of this loan defaulting.


RESPONSE FORMAT (JSON only):
{
  "defaultProbability": <number 0-1>,
  "defaultRisk": "LOW" | "MEDIUM" | "HIGH",
  "warningSignals": [
    "<signal 1>",
    "<signal 2>"
  ],
  "recommendations": [
    "<recommendation 1>",
    "<recommendation 2>"
  ]
}


Provide your prediction now:`;
  }
}
3.3 Risk Scoring Engine
// src/ai/riskScoringEngine.ts
import { geminiClient } from './geminiClient';
import { GeminiPrompts, RiskScoringInput, RiskScoringOutput } from './geminiPrompts';
import { dataAnonymizer } from './dataAnonymizer';
import User, { IUser } from '../models/User';
import Loan from '../models/Loan';
import Installment, { InstallmentStatus } from '../models/Installment';
import RiskProfile, { IRiskProfile, RiskLevel } from '../models/RiskProfile';
import logger from '../utils/logger';


class RiskScoringEngine {
  
  /**
   * Calculate risk score for a user
   */
  async calculateRiskScore(userId: string, options?: {
    requestedAmount?: number;
    requestedTenure?: number;
    forceRecalculate?: boolean;
  }): Promise<IRiskProfile> {
    logger.info('Starting risk score calculation', { userId, options });
    
    // Check for existing risk profile
    if (!options?.forceRecalculate) {
      const existing = await RiskProfile.findOne({ userId });
      if (existing) {
        const hoursSinceCalculation = 
          (Date.now() - existing.lastCalculated.getTime()) / (1000 * 60 * 60);
        
        // Use cached risk profile if calculated within last 24 hours
        if (hoursSinceCalculation < 24) {
          logger.info('Using cached risk profile', { userId, age: hoursSinceCalculation });
          return existing;
        }
      }
    }
    
    // Fetch user data
    const user = await User.findById(userId);
    if (!user) {
      throw new Error('User not found');
    }
    
    // Build anonymized input
    const input = await this.buildRiskScoringInput(user, options);
    
    // Generate prompt
    const prompt = GeminiPrompts.buildRiskScoringPrompt(input);
    
    // Call Gemini
    const geminiResponse = await geminiClient.generateStructuredContent<RiskScoringOutput>(prompt);
    
    // Validate response
    this.validateRiskScoringOutput(geminiResponse);
    
    // Save or update risk profile
    const riskProfile = await RiskProfile.findOneAndUpdate(
      { userId },
      {
        userId,
        riskLevel: geminiResponse.riskLevel,
        riskScore: geminiResponse.riskScore,
        riskReasons: geminiResponse.riskReasons,
        recommendedMaxLoan: geminiResponse.recommendedMaxLoan,
        recommendedTenure: geminiResponse.recommendedTenure,
        defaultProbability: geminiResponse.defaultProbability,
        geminiResponse: {
          raw: JSON.stringify(geminiResponse),
          model: 'gemini-1.5-flash',
          tokensUsed: 0,
          timestamp: new Date()
        },
        lastCalculated: new Date()
      },
      { upsert: true, new: true }
    );
    
    logger.info('Risk score calculated successfully', {
      userId,
      riskLevel: riskProfile.riskLevel,
      riskScore: riskProfile.riskScore
    });
    
    return riskProfile;
  }
  
  /**
   * Build anonymized input for Gemini
   */
  private async buildRiskScoringInput(
    user: IUser,
    options?: { requestedAmount?: number; requestedTenure?: number; }
  ): Promise<RiskScoringInput> {
    // Get anonymized profile
    const anonymizedProfile = user.getAnonymizedProfile();
    
    // Fetch loan history
    const loans = await Loan.find({ userId: user._id });
    
    let loanHistory;
    if (loans.length > 0) {
      const loanIds = loans.map(l => l._id);
      const installments = await Installment.find({ loanId: { $in: loanIds } });
      
      const completed = loans.filter(l => l.status === 'COMPLETED').length;
      const defaulted = loans.filter(l => l.status === 'DEFAULTED').length;
      
      const paid = installments.filter(i => i.status === InstallmentStatus.PAID);
      const overdue = installments.filter(i => i.status === InstallmentStatus.OVERDUE);
      const missed = installments.filter(i => i.status === InstallmentStatus.DEFAULTED);
      
      const totalDelay = paid.reduce((sum, inst) => {
        if (inst.paidDate && inst.dueDate) {
          const delay = Math.max(0, Math.floor(
            (inst.paidDate.getTime() - inst.dueDate.getTime()) / (1000 * 60 * 60 * 24)
          ));
          return sum + delay;
        }
        return sum;
      }, 0);
      
      loanHistory = {
        totalLoans: loans.length,
        completedLoans: completed,
        defaultedLoans: defaulted,
        onTimePayments: paid.length - overdue.length,
        latePayments: overdue.length,
        missedPayments: missed.length,
        averagePaymentDelay: paid.length > 0 ? Math.round(totalDelay / paid.length) : 0
      };
    }
    
    return {
      ...anonymizedProfile,
      requestedAmount: options?.requestedAmount,
      requestedTenure: options?.requestedTenure,
      loanHistory
    };
  }
  
  /**
   * Validate Gemini response
   */
  private validateRiskScoringOutput(output: any): void {
    if (!output.riskLevel || !['LOW', 'MEDIUM', 'HIGH'].includes(output.riskLevel)) {
      throw new Error('Invalid riskLevel in Gemini response');
    }
    
    if (typeof output.riskScore !== 'number' || output.riskScore < 0 || output.riskScore > 100) {
      throw new Error('Invalid riskScore in Gemini response');
    }
    
    if (!Array.isArray(output.riskReasons) || output.riskReasons.length === 0) {
      throw new Error('Invalid riskReasons in Gemini response');
    }
  }
  
  /**
   * Predict default risk for active loan
   */
  async predictDefaultRisk(loanId: string): Promise<{
    defaultProbability: number;
    defaultRisk: string;
    warningSignals: string[];
    recommendations: string[];
  }> {
    const loan = await Loan.findById(loanId).populate('userId');
    if (!loan) {
      throw new Error('Loan not found');
    }
    
    const installments = await Installment.find({ loanId });
    
    const paid = installments.filter(i => i.status === InstallmentStatus.PAID);
    const overdue = installments.filter(i => i.status === InstallmentStatus.OVERDUE);
    
    const totalDelay = paid.reduce((sum, inst) => {
      if (inst.paidDate && inst.dueDate) {
        const delay = Math.max(0, Math.floor(
          (inst.paidDate.getTime() - inst.dueDate.getTime()) / (1000 * 60 * 60 * 24)
        ));
        return sum + delay;
      }
      return sum;
    }, 0);
    
    const input = {
      currentLoan: {
        principalAmount: loan.principalAmount,
        outstandingBalance: loan.outstandingBalance,
        monthsRemaining: loan.tenureMonths - paid.length
      },
      paymentBehavior: {
        totalInstallments: installments.length,
        paidInstallments: paid.length,
        overdueInstallments: overdue.length,
        averageDelayDays: paid.length > 0 ? Math.round(totalDelay / paid.length) : 0
      },
      financialProfile: (loan.userId as IUser).getAnonymizedProfile()
    };
    
    const prompt = GeminiPrompts.buildDefaultPredictionPrompt(input);
    const response = await geminiClient.generateStructuredContent<any>(prompt);
    
    return response;
  }
}


export const riskScoringEngine = new RiskScoringEngine();
3.4 Data Anonymizer
// src/ai/dataAnonymizer.ts


/**
 * Ensures no PII is sent to Gemini API
 */
class DataAnonymizer {
  
  /**
   * Remove all PII from user data
   */
  anonymizeUser(user: any): any {
    return {
      // NEVER include:
      // - cnic / cnicHash
      // - fullName
      // - phone
      // - email
      // - address
      
      // Safe to include (derived/generalized):
      ageBracket: this.getAgeBracket(user.cnic),
      incomeRange: this.getIncomeRange(user.monthlyIncome),
      employmentType: user.employmentType,
      city: user.city,
      province: user.province,
      accountAgeInDays: this.getAccountAge(user.create
      accountAgeInDays: this.getAccountAge(user.createdAt)
    };
  }
  
  /**
   * Get age bracket from CNIC without exposing actual CNIC
   */
  private getAgeBracket(cnic: string): string {
    // Parse CNIC to get age, then return bracket
    // This should use the decrypted CNIC
    try {
      const dateStr = cnic.substring(6, 12);
      const day = parseInt(dateStr.substring(0, 2));
      const month = parseInt(dateStr.substring(2, 4)) - 1;
      let year = parseInt(dateStr.substring(4, 6));
      
      year += (year > 30 ? 1900 : 2000);
      
      const birthDate = new Date(year, month, day);
      const age = Math.floor((Date.now() - birthDate.getTime()) / (1000 * 60 * 60 * 24 * 365.25));
      
      if (age < 25) return '18-24';
      if (age < 35) return '25-34';
      if (age < 45) return '35-44';
      if (age < 55) return '45-54';
      return '55+';
    } catch {
      return 'unknown';
    }
  }
  
  /**
   * Convert income to range
   */
  private getIncomeRange(income: number): string {
    if (income < 30000) return 'under-30k';
    if (income < 50000) return '30k-50k';
    if (income < 75000) return '50k-75k';
    if (income < 100000) return '75k-100k';
    return 'above-100k';
  }
  
  /**
   * Get account age in days
   */
  private getAccountAge(createdAt: Date): number {
    return Math.floor((Date.now() - new Date(createdAt).getTime()) / (1000 * 60 * 60 * 24));
  }
  
  /**
   * Validate that no PII is present
   */
  validateNoPII(data: any): boolean {
    const dataStr = JSON.stringify(data).toLowerCase();
    
    // Check for common PII patterns
    const hasCNIC = /\d{5}-\d{7}-\d/.test(dataStr);
    const hasEmail = /@/.test(dataStr);
    const hasPhone = /(\+92|03)\d{9}/.test(dataStr);
    
    if (hasCNIC || hasEmail || hasPhone) {
      throw new Error('PII detected in data being sent to AI - blocking request');
    }
    
    return true;
  }
}


export const dataAnonymizer = new DataAnonymizer();
3.5 Response Parser
// src/ai/responseParser.ts
import logger from '../utils/logger';


class ResponseParser {
  
  /**
   * Safely parse Gemini JSON response
   */
  parseRiskScoringResponse(rawResponse: string): any {
    try {
      // Remove markdown code blocks
      let cleaned = rawResponse.trim();
      cleaned = cleaned.replace(/```json\n?/g, '');
      cleaned = cleaned.replace(/```\n?/g, '');
      cleaned = cleaned.trim();
      
      // Parse JSON
      const parsed = JSON.parse(cleaned);
      
      // Validate structure
      if (!this.isValidRiskScoringResponse(parsed)) {
        throw new Error('Invalid risk scoring response structure');
      }
      
      return parsed;
      
    } catch (error: any) {
      logger.error('Failed to parse Gemini response', {
        rawResponse,
        error: error.message
      });
      throw new Error(`Failed to parse AI response: ${error.message}`);
    }
  }
  
  /**
   * Validate risk scoring response structure
   */
  private isValidRiskScoringResponse(data: any): boolean {
    return (
      data &&
      typeof data === 'object' &&
      ['LOW', 'MEDIUM', 'HIGH'].includes(data.riskLevel) &&
      typeof data.riskScore === 'number' &&
      data.riskScore >= 0 &&
      data.riskScore <= 100 &&
      Array.isArray(data.riskReasons) &&
      data.riskReasons.length > 0
    );
  }
  
  /**
   * Extract and sanitize reasons
   */
  sanitizeReasons(reasons: string[]): string[] {
    return reasons
      .filter(r => typeof r === 'string' && r.length > 0)
      .map(r => r.trim())
      .slice(0, 10); // Max 10 reasons
  }
}


export const responseParser = new ResponseParser();
________________


4. FRONTEND DESIGN
4.1 Next.js App Structure
/app
├── (auth)/
│   ├── login/
│   │   └── page.tsx
│   ├── register/
│   │   └── page.tsx
│   └── layout.tsx
│
├── (user)/
│   ├── dashboard/
│   │   ├── page.tsx                    # Main user dashboard
│   │   ├── loan/
│   │   │   └── page.tsx                # Loan details
│   │   ├── installments/
│   │   │   ├── page.tsx                # Installments list
│   │   │   └── [id]/
│   │   │       └── page.tsx            # Single installment detail
│   │   ├── profile/
│   │   │   └── page.tsx                # User profile
│   │   └── risk-profile/
│   │       └── page.tsx                # Risk profile view
│   └── layout.tsx                      # User layout with sidebar
│
├── (admin)/
│   ├── admin/
│   │   ├── dashboard/
│   │   │   └── page.tsx                # Admin main dashboard
│   │   ├── users/
│   │   │   ├── page.tsx                # Users list
│   │   │   ├── pending/
│   │   │   │   └── page.tsx            # Pending approvals
│   │   │   └── [id]/
│   │   │       ├── page.tsx            # User detail
│   │   │       └── create-loan/
│   │   │           └── page.tsx        # Create loan form
│   │   ├── loans/
│   │   │   ├── page.tsx                # All loans
│   │   │   └── [id]/
│   │   │       └── page.tsx            # Loan detail
│   │   ├── installments/
│   │   │   ├── page.tsx                # All installments
│   │   │   ├── overdue/
│   │   │   │   └── page.tsx            # Overdue installments
│   │   │   └── defaults/
│   │   │       └── page.tsx            # Defaulted loans
│   │   ├── analytics/
│   │   │   └── page.tsx                # Analytics dashboard
│   │   └── settings/
│   │       └── page.tsx                # System settings
│   └── layout.tsx                      # Admin layout
│
├── api/
│   └── auth/
│       └── [...nextauth]/
│           └── route.ts                # NextAuth config (optional)
│
├── components/
│   ├── ui/                             # shadcn/ui components
│   │   ├── button.tsx
│   │   ├── card.tsx
│   │   ├── dialog.tsx
│   │   ├── form.tsx
│   │   ├── input.tsx
│   │   ├── table.tsx
│   │   └── ...
│   ├── auth/
│   │   ├── LoginForm.tsx
│   │   └── RegisterForm.tsx
│   ├── dashboard/
│   │   ├── StatsCard.tsx
│   │   ├── LoanSummary.tsx
│   │   └── InstallmentsList.tsx
│   ├── admin/
│   │   ├── UserApprovalCard.tsx
│   │   ├── RiskProfileCard.tsx
│   │   ├── LoanCreationForm.tsx
│   │   └── AnalyticsCharts.tsx
│   ├── layout/
│   │   ├── Navbar.tsx
│   │   ├── Sidebar.tsx
│   │   └── Footer.tsx
│   └── shared/
│       ├── LoadingSpinner.tsx
│       ├── ErrorMessage.tsx
│       └── ConfirmDialog.tsx
│
├── lib/
│   ├── api-client.ts                   # Axios instance
│   ├── auth.ts                         # Auth utilities
│   └── utils.ts                        # General utilities
│
├── hooks/
│   ├── useAuth.ts
│   ├── useLoan.ts
│   ├── useInstallments.ts
│   └── useToast.ts
│
├── services/
│   ├── authService.ts
│   ├── userService.ts
│   ├── adminService.ts
│   ├── loanService.ts
│   └── paymentService.ts
│
├── types/
│   ├── user.ts
│   ├── loan.ts
│   ├── installment.ts
│   ├── risk.ts
│   └── api.ts
│
├── context/
│   ├── AuthContext.tsx
│   └── ToastContext.tsx
│
├── middleware.ts                       # Route protection
├── layout.tsx                          # Root layout
└── page.tsx                            # Landing page
4.2 TypeScript Types/Interfaces
// src/types/user.ts
export enum UserStatus {
  PENDING = 'PENDING',
  APPROVED = 'APPROVED',
  REJECTED = 'REJECTED'
}


export enum UserRole {
  USER = 'USER',
  ADMIN = 'ADMIN'
}


export interface User {
  id: string;
  fullName: string;
  email: string;
  phone: string;
  address: string;
  city: string;
  province: string;
  monthlyIncome: number;
  employmentType: string;
  employerName?: string;
  status: UserStatus;
  role: UserRole;
  createdAt: string;
  lastLoginAt?: string;
}


export interface AuthResponse {
  accessToken: string;
  refreshToken: string;
  user: User;
}
// src/types/loan.ts
export enum LoanStatus {
  ACTIVE = 'ACTIVE',
  COMPLETED = 'COMPLETED',
  DEFAULTED = 'DEFAULTED',
  CANCELLED = 'CANCELLED'
}


export interface Loan {
  id: string;
  userId: string;
  principalAmount: number;
  interestRate: number;
  tenureMonths: number;
  monthlyInstallment: number;
  totalAmount: number;
  outstandingBalance: number;
  totalRepaid: number;
  totalFines: number;
  startDate: string;
  endDate: string;
  status: LoanStatus;
  installmentSchedule: InstallmentScheduleItem[];
  createdAt: string;
}


export interface InstallmentScheduleItem {
  month: number;
  dueDate: string;
  amount: number;
}
// src/types/installment.ts
export enum InstallmentStatus {
  PENDING = 'PENDING',
  PAID = 'PAID',
  OVERDUE = 'OVERDUE',
  DEFAULTED = 'DEFAULTED'
}


export interface Installment {
  id: string;
  loanId: string;
  installmentNumber: number;
  amount: number;
  fineAmount: number;
  totalDue: number;
  dueDate: string;
  paidDate?: string;
  status: InstallmentStatus;
  daysOverdue: number;
  gracePeriodEndDate: string;
  stripeSessionId?: string;
  paymentLink?: string;
}
// src/types/risk.ts
export enum RiskLevel {
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH'
}


export interface RiskProfile {
  userId: string;
  riskLevel: RiskLevel;
  riskScore: number;
  riskReasons: string[];
  recommendedMaxLoan?: number;
  recommendedTenure?: number;
  defaultProbability?: number;
  lastCalculated: string;
}
4.3 API Client Setup
// src/lib/api-client.ts
import axios, { AxiosInstance, AxiosError } from 'axios';
import { toast } from '@/hooks/useToast';


class ApiClient {
  private client: AxiosInstance;
  
  constructor() {
    this.client = axios.create({
      baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000/api',
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    this.setupInterceptors();
  }
  
  private setupInterceptors() {
    // Request interceptor: Add auth token
    this.client.interceptors.request.use(
      (config) => {
        const token = this.getAccessToken();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );
    
    // Response interceptor: Handle errors and token refresh
    this.client.interceptors.response.use(
      (response) => response,
      async (error: AxiosError) => {
        const originalRequest = error.config as any;
        
        // Handle 401 - Token expired
        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;
          
          try {
            const newToken = await this.refreshAccessToken();
            if (newToken) {
              originalRequest.headers.Authorization = `Bearer ${newToken}`;
              return this.client(originalRequest);
            }
          } catch (refreshError) {
            this.handleAuthError();
            return Promise.reject(refreshError);
          }
        }
        
        // Handle other errors
        this.handleError(error);
        return Promise.reject(error);
      }
    );
  }
  
  private getAccessToken(): string | null {
    if (typeof window !== 'undefined') {
      return localStorage.getItem('accessToken');
    }
    return null;
  }
  
  private async refreshAccessToken(): Promise<string | null> {
    try {
      const refreshToken = localStorage.getItem('refreshToken');
      if (!refreshToken) return null;
      
      const response = await axios.post(
        `${process.env.NEXT_PUBLIC_API_URL}/auth/refresh`,
        { refreshToken }
      );
      
      const { accessToken } = response.data.data;
      localStorage.setItem('accessToken', accessToken);
      return accessToken;
      
    } catch {
      return null;
    }
  }
  
  private handleAuthError() {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
    window.location.href = '/login';
  }
  
  private handleError(error: AxiosError) {
    if (error.response) {
      const message = (error.response.data as any)?.message || 'An error occurred';
      toast({
        title: 'Error',
        description: message,
        variant: 'destructive'
      });
    } else if (error.request) {
      toast({
        title: 'Network Error',
        description: 'Unable to reach the server',
        variant: 'destructive'
      });
    }
  }
  
  public getInstance(): AxiosInstance {
    return this.client;
  }
}


export const apiClient = new ApiClient().getInstance();
4.4 Authentication Service
// src/services/authService.ts
import { apiClient } from '@/lib/api-client';
import { AuthResponse, User } from '@/types/user';


export const authService = {
  /**
   * Register new user
   */
  async register(data: {
    fullName: string;
    cnic: string;
    phone: string;
    email: string;
    password: string;
    address: string;
    city: string;
    province: string;
    monthlyIncome: number;
    employmentType: string;
    employerName?: string;
  }): Promise<{ userId: string; email: string; status: string }> {
    const response = await apiClient.post('/auth/register', data);
    return response.data.data;
  },
  
  /**
   * Login
   */
  async login(email: string, password: string): Promise<AuthResponse> {
    const response = await apiClient.post('/auth/login', { email, password });
    const { accessToken, refreshToken, user } = response.data.data;
    
    // Store tokens
    if (typeof window !== 'undefined') {
      localStorage.setItem('accessToken', accessToken);
      localStorage.setItem('refreshToken', refreshToken);
    }
    
    return response.data.data;
  },
  
  /**
   * Logout
   */
  async logout(): Promise<void> {
    try {
      await apiClient.post('/auth/logout');
    } finally {
      if (typeof window !== 'undefined') {
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
      }
    }
  },
  
  /**
   * Get current user
   */
  async getCurrentUser(): Promise<User> {
    const response = await apiClient.get('/auth/me');
    return response.data.data;
  },
  
  /**
   * Check if user is authenticated
   */
  isAuthenticated(): boolean {
    if (typeof window !== 'undefined') {
      return !!localStorage.getItem('accessToken');
    }
    return false;
  }
};
4.5 Key React Components
Login Form Component
// src/components/auth/LoginForm.tsx
'use client';


import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { authService } from '@/services/authService';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { useToast } from '@/hooks/useToast';


export function LoginForm() {
  const router = useRouter();
  const { toast } = useToast();
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState({
    email: '',
    password: ''
  });
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    
    try {
      const { user } = await authService.login(formData.email, formData.password);
      
      toast({
        title: 'Login Successful',
        description: `Welcome back, ${user.fullName}!`
      });
      
      // Redirect based on role
      if (user.role === 'ADMIN') {
        router.push('/admin/dashboard');
      } else {
        router.push('/dashboard');
      }
      
    } catch (error: any) {
      toast({
        title: 'Login Failed',
        description: error.response?.data?.message || 'Invalid credentials',
        variant: 'destructive'
      });
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <Card className="w-full max-w-md">
      <CardHeader>
        <CardTitle className="text-2xl">Login to Your Account</CardTitle>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              value={formData.email}
              onChange={(e) => setFormData({ ...formData, email: e.target.value })}
              required
            />
          </div>
          
          <div>
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={formData.password}
              onChange={(e) => setFormData({ ...formData, password: e.target.value })}
              required
            />
          </div>
          
          <Button type="submit" className="w-full" disabled={loading}>
            {loading ? 'Logging in...' : 'Login'}
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}
User Dashboard Stats Component
// src/components/dashboard/StatsCard.tsx
'use client';


import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { LucideIcon } from 'lucide-react';


interface StatsCardProps {
  title: string;
  value: string | number;
  icon: LucideIcon;
  description?: string;
  trend?: {
    value: number;
    isPositive: boolean;
  };
}


export function StatsCard({ title, value, icon: Icon, description, trend }: StatsCardProps) {
  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between pb-2">
        <CardTitle className="text-sm font-medium text-muted-foreground">
          {title}
        </CardTitle>
        <Icon className="h-4 w-4 text-muted-foreground" />
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
        {description && (
          <p className="text-xs text-muted-foreground mt-1">{description}</p>
        )}
        {trend && (
          <div className={`text-xs mt-1 ${trend.isPositive ? 'text-green-600' : 'text-red-600'}`}>
            {trend.isPositive ? '↑' : '↓'} {Math.abs(trend.value)}%
          </div>
        )}
      </CardContent>
    </Card>
  );
}
Risk Profile Display Component
// src/components/admin/RiskProfileCard.tsx
'use client';


import { RiskProfile, RiskLevel } from '@/types/risk';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { AlertTriangle, CheckCircle, XCircle } from 'lucide-react';


interface RiskProfileCardProps {
  riskProfile: RiskProfile;
}


export function RiskProfileCard({ riskProfile }: RiskProfileCardProps) {
  const getRiskColor = (level: RiskLevel) => {
    switch (level) {
      case RiskLevel.LOW:
        return 'bg-green-100 text-green-800';
      case RiskLevel.MEDIUM:
        return 'bg-yellow-100 text-yellow-800';
      case RiskLevel.HIGH:
        return 'bg-red-100 text-red-800';
    }
  };
  
  const getRiskIcon = (level: RiskLevel) => {
    switch (level) {
      case RiskLevel.LOW:
        return <CheckCircle className="h-5 w-5 text-green-600" />;
      case RiskLevel.MEDIUM:
        return <AlertTriangle className="h-5 w-5 text-yellow-600" />;
      case RiskLevel.HIGH:
        return <XCircle className="h-5 w-5 text-red-600" />;
    }
  };
  
  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          AI Risk Assessment
          <Badge className={getRiskColor(riskProfile.riskLevel)}>
            {riskProfile.riskLevel}
          </Badge>
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="flex items-center gap-3">
          {getRiskIcon(riskProfile.riskLevel)}
          <div>
            <p className="text-sm font-medium">Risk Score</p>
            <p className="text-2xl font-bold">{riskProfile.riskScore}/100</p>
          </div>
        </div>
        
        <div>
          <p className="text-sm font-medium mb-2">Risk Factors:</p>
          <ul className="space-y-1">
            {riskProfile.riskReasons.map((reason, index) => (
              <li key={index} className="text-sm text-muted-foreground flex items-start gap-2">
                <span className="text-primary">•</span>
                {reason}
              </li>
            ))}
          </ul>
        </div>
        
        {riskProfile.recommendedMaxLoan && (
          <div className="pt-4 border-t">
            <p className="text-sm font-medium">AI Recommendations:</p>
            <div className="mt-2 space-y-1">
              <p className="text-sm">
                Max Loan: <span className="font-semibold">PKR {riskProfile.recommendedMaxLoan.toLocaleString()}</span>
              </p>
              <p className="text-sm">
                Max Tenure: <span className="font-semibold">{riskProfile.recommendedTenure} months</span>
              </p>
              {riskProfile.defaultProbability && (
                <p className="text-sm">
                  Default Risk: <span className="font-semibold">{(riskProfile.defaultProbability * 100).toFixed(1)}%</span>
                </p>
              )}
            </div>
          </div>
        )}
        
        <p className="text-xs text-muted-foreground">
          Last calculated: {new Date(riskProfile.lastCalculated).toLocaleString()}
        </p>
      </CardContent>
    </Card>
  );
}
4.6 Middleware for Route Protection
// src/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';


export function middleware(request: NextRequest) {
  const accessToken = request.cookies.get('accessToken')?.value;
  const { pathname } = request.nextUrl;
  
  // Public routes
  const publicRoutes = ['/login', '/register', '/'];
  const isPublicRoute = publicRoutes.some(route => pathname.startsWith(route));
  
  // Admin routes
  const isAdminRoute = pathname.startsWith('/admin');
  
  // User routes
  const isUserRoute = pathname.startsWith('/dashboard');
  
  // Redirect unauthenticated users
  if (!accessToken && !isPublicRoute) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
  
  // Redirect authenticated users away from auth pages
  if (accessToken && isPublicRoute && pathname !== '/') {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }
  
  // Role-based access would require decoding JWT here
  // For production, implement proper JWT verification
  
  return NextResponse.next();
}


export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)']
};
________________


5. SECURITY, COMPLIANCE & PRIVACY
5.1 Authentication & Authorization
JWT Strategy:
* Access Token: Short-lived (15 minutes), stored in memory or httpOnly cookie
* Refresh Token: Long-lived (7 days), stored in httpOnly cookie with secure flag
* Token Payload: { userId, role, email, iat, exp }
* Secret Key: Strong, environment-specific, rotated periodically
// JWT Implementation
import jwt from 'jsonwebtoken';
import { config } from '../config/environment';


export const generateTokens = (payload: { userId: string; role: string; email: string }) => {
  const accessToken = jwt.sign(payload, config.jwt.accessSecret, {
    expiresIn: '15m'
  });
  
  const refreshToken = jwt.sign(payload, config.jwt.refreshSecret, {
    expiresIn: '7d'
  });
  
  return { accessToken, refreshToken };
};


export const verifyAccessToken = (token: string) => {
  try {
    return jwt.verify(token, config.jwt.accessSecret);
  } catch (error) {
    throw new Error('Invalid or expired token');
  }
};
Role-Based Access Control (RBAC):
// src/middlewares/roleCheck.middleware.ts
import { Request, Response, NextFunction } from 'express';


export const requireRole = (...allowedRoles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const user = (req as any).user;
    
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Authentication required'
      });
    }
    
    if (!allowedRoles.includes(user.role)) {
      return res.status(403).json({
        success: false,
        message: 'Insufficient permissions'
      });
    }
    
    next();
  };
};


// Usage:
router.get('/admin/users', authenticate, requireRole('ADMIN'), adminController.getUsers);
5.2 Data Encryption & Privacy
Field-Level Encryption for CNIC:
// src/utils/encryption.ts
import crypto from 'crypto';
import { config } from '../config/environment';


const ALGORITHM = 'aes-256-gcm';
const KEY = crypto.scryptSync(config.encryption.secret, 'salt', 32);


export const encrypt = (text: string): string => {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(ALGORITHM, KEY, iv);
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return `enc:${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
};


export const decrypt = (encryptedText: string): string => {
  if (!encryptedText.startsWith('enc:')) {
    throw new Error('Invalid encrypted format');
  }
  
  const parts = encryptedText.split(':');
  const iv = Buffer.from(parts[1], 'hex');
  const authTag = Buffer.from(parts[2], 'hex');
  const encrypted = parts[3];
  
  const decipher = crypto.createDecipheriv(ALGORITHM, KEY, iv);
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
};
Password Hashing:
* Use bcrypt with cost factor 12
* Never store plain-text passwords
* Implement password complexity requirements
**PII Protection
PII Protection for AI Calls:
// src/ai/dataAnonymizer.ts (Extended)


/**
 * CRITICAL: Ensure NO Personally Identifiable Information (PII) 
 * is ever sent to Google Gemini API
 */
export class PIIProtectionLayer {
  
  private static readonly BLOCKED_FIELDS = [
    'cnic',
    'cnicHash',
    'fullName',
    'email',
    'phone',
    'address',
    'password',
    'passwordHash',
    'ssn',
    'accountNumber'
  ];
  
  /**
   * Scrub object of all PII before sending to AI
   */
  static scrubPII(data: any): any {
    if (typeof data !== 'object' || data === null) {
      return data;
    }
    
    const scrubbed: any = Array.isArray(data) ? [] : {};
    
    for (const key in data) {
      // Block any field that might contain PII
      if (this.BLOCKED_FIELDS.some(blocked => key.toLowerCase().includes(blocked.toLowerCase()))) {
        continue; // Skip this field entirely
      }
      
      if (typeof data[key] === 'object') {
        scrubbed[key] = this.scrubPII(data[key]);
      } else {
        scrubbed[key] = data[key];
      }
    }
    
    return scrubbed;
  }
  
  /**
   * Validate that no PII patterns exist in final payload
   */
  static validateNoPII(payload: string): void {
    // Check for email patterns
    if (/@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/.test(payload)) {
      throw new Error('SECURITY VIOLATION: Email detected in AI payload');
    }
    
    // Check for Pakistani phone patterns
    if (/(\+92|0)?3\d{9}/.test(payload)) {
      throw new Error('SECURITY VIOLATION: Phone number detected in AI payload');
    }
    
    // Check for CNIC patterns
    if (/\d{5}-?\d{7}-?\d/.test(payload)) {
      throw new Error('SECURITY VIOLATION: CNIC detected in AI payload');
    }
    
    // Check for common PII keywords (case insensitive)
    const piiKeywords = ['cnic', 'fullname', 'password', 'email', 'phone'];
    const lowerPayload = payload.toLowerCase();
    
    for (const keyword of piiKeywords) {
      if (lowerPayload.includes(keyword)) {
        throw new Error(`SECURITY VIOLATION: PII keyword "${keyword}" detected in AI payload`);
      }
    }
  }
  
  /**
   * Audit log all AI calls for compliance
   */
  static async auditAICall(params: {
    userId: string;
    purpose: string;
    inputSize: number;
    outputSize: number;
    model: string;
    timestamp: Date;
  }): Promise<void> {
    await AuditLog.create({
      userId: params.userId,
      action: 'AI_API_CALL',
      entity: 'Gemini',
      metadata: {
        purpose: params.purpose,
        inputSize: params.inputSize,
        outputSize: params.outputSize,
        model: params.model
      }
    });
  }
}
5.3 Stripe Webhook Security
// src/stripe/signatureVerifier.ts
import Stripe from 'stripe';
import { config } from '../config/environment';
import logger from '../utils/logger';


export class StripeWebhookVerifier {
  private stripe: Stripe;
  
  constructor() {
    this.stripe = new Stripe(config.stripe.secretKey, {
      apiVersion: '2023-10-16'
    });
  }
  
  /**
   * Verify webhook signature
   */
  verifySignature(payload: string, signature: string): Stripe.Event {
    try {
      const event = this.stripe.webhooks.constructEvent(
        payload,
        signature,
        config.stripe.webhookSecret
      );
      
      logger.info('Stripe webhook signature verified', {
        eventType: event.type,
        eventId: event.id
      });
      
      return event;
      
    } catch (error: any) {
      logger.error('Stripe webhook signature verification failed', {
        error: error.message
      });
      throw new Error('Invalid webhook signature');
    }
  }
  
  /**
   * Validate event is not too old (replay attack protection)
   */
  validateEventAge(event: Stripe.Event, maxAgeMinutes: number = 5): boolean {
    const eventTime = event.created * 1000; // Convert to milliseconds
    const now = Date.now();
    const ageMinutes = (now - eventTime) / (1000 * 60);
    
    if (ageMinutes > maxAgeMinutes) {
      logger.warn('Stripe webhook event too old', {
        eventId: event.id,
        ageMinutes
      });
      return false;
    }
    
    return true;
  }
}


// Webhook endpoint implementation
// src/routes/payment.routes.ts
import express, { Request, Response } from 'express';
import { StripeWebhookVerifier } from '../stripe/signatureVerifier';


router.post('/stripe/webhook', 
  express.raw({ type: 'application/json' }), // IMPORTANT: Raw body needed for signature verification
  async (req: Request, res: Response) => {
    const signature = req.headers['stripe-signature'] as string;
    
    if (!signature) {
      return res.status(400).json({ error: 'Missing signature' });
    }
    
    try {
      const verifier = new StripeWebhookVerifier();
      const event = verifier.verifySignature(req.body.toString(), signature);
      
      // Validate event age
      if (!verifier.validateEventAge(event)) {
        return res.status(400).json({ error: 'Event too old' });
      }
      
      // Process event
      await webhookHandler.handleEvent(event);
      
      res.json({ received: true });
      
    } catch (error: any) {
      logger.error('Webhook processing failed', { error: error.message });
      res.status(400).json({ error: error.message });
    }
  }
);
5.4 Rate Limiting & DDoS Protection
// src/middlewares/rateLimiter.middleware.ts
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import Redis from 'ioredis';
import { config } from '../config/environment';


// Redis client for distributed rate limiting
const redis = new Redis(config.redis.url);


/**
 * General API rate limiter
 */
export const apiLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rl:api:'
  }),
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // 100 requests per window
  message: 'Too many requests, please try again later',
  standardHeaders: true,
  legacyHeaders: false
});


/**
 * Auth endpoint rate limiter (stricter)
 */
export const authLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rl:auth:'
  }),
  windowMs: 15 * 60 * 1000,
  max: 5, // Only 5 login attempts per 15 minutes
  skipSuccessfulRequests: true,
  message: 'Too many login attempts, please try again later'
});


/**
 * Payment endpoint rate limiter
 */
export const paymentLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rl:payment:'
  }),
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 10, // 10 payment attempts per hour
  message: 'Payment rate limit exceeded'
});


// Usage in routes:
// router.post('/auth/login', authLimiter, authController.login);
// router.post('/payments/create-checkout-session', paymentLimiter, paymentController.createCheckout);
5.5 Security Headers & CORS
// src/app.ts
import express from 'express';
import helmet from 'helmet';
import cors from 'cors';
import { config } from './config/environment';


const app = express();


// Security headers with Helmet
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'", "https://js.stripe.com"],
      frameSrc: ["https://js.stripe.com", "https://hooks.stripe.com"],
      connectSrc: ["'self'", "https://api.stripe.com"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));


// CORS configuration
app.use(cors({
  origin: config.frontend.url,
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));


// Body parsing with size limits
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));


export default app;
5.6 Input Validation & Sanitization
// src/validations/user.validation.ts
import { z } from 'zod';


export const registerSchema = z.object({
  fullName: z.string()
    .min(3, 'Name must be at least 3 characters')
    .max(100, 'Name cannot exceed 100 characters')
    .regex(/^[a-zA-Z\s]+$/, 'Name can only contain letters and spaces'),
  
  cnic: z.string()
    .regex(/^\d{5}-\d{7}-\d$/, 'Invalid CNIC format (XXXXX-XXXXXXX-X)'),
  
  phone: z.string()
    .regex(/^(\+92|0)?3\d{9}$/, 'Invalid Pakistani phone number'),
  
  email: z.string()
    .email('Invalid email address')
    .toLowerCase(),
  
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Password must contain uppercase, lowercase, and number'),
  
  address: z.string()
    .min(10, 'Address too short')
    .max(500, 'Address too long'),
  
  city: z.string()
    .min(2, 'City name too short'),
  
  province: z.enum(['Punjab', 'Sindh', 'KPK', 'Balochistan', 'Gilgit-Baltistan', 'AJK']),
  
  monthlyIncome: z.number()
    .min(0, 'Income cannot be negative')
    .max(10000000, 'Income value too high'),
  
  employmentType: z.enum(['SALARIED', 'SELF_EMPLOYED', 'BUSINESS_OWNER', 'DAILY_WAGE', 'UNEMPLOYED']),
  
  employerName: z.string().optional()
});


export const loanCreationSchema = z.object({
  principalAmount: z.number()
    .min(5000, 'Minimum loan amount is PKR 5,000')
    .max(500000, 'Maximum loan amount is PKR 500,000'),
  
  interestRate: z.number()
    .min(0, 'Interest rate cannot be negative')
    .max(30, 'Interest rate cannot exceed 30%'),
  
  tenureMonths: z.number()
    .int('Tenure must be a whole number')
    .min(3, 'Minimum tenure is 3 months')
    .max(60, 'Maximum tenure is 60 months'),
  
  startDate: z.string()
    .datetime('Invalid date format'),
  
  notes: z.string()
    .max(1000, 'Notes too long')
    .optional()
});


// Validation middleware
// src/middlewares/validation.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { ZodSchema } from 'zod';


export const validate = (schema: ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      schema.parse(req.body);
      next();
    } catch (error: any) {
      res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: error.errors
      });
    }
  };
};


// Usage:
// router.post('/auth/register', validate(registerSchema), authController.register);
5.7 Audit Logging & Compliance
// src/services/auditService.ts
import AuditLog, { AuditAction } from '../models/AuditLog';
import logger from '../utils/logger';


class AuditService {
  
  /**
   * Log an audit event
   */
  async log(params: {
    userId?: string;
    performedBy?: string;
    action: AuditAction;
    entity: string;
    entityId?: string;
    oldValue?: any;
    newValue?: any;
    ipAddress?: string;
    userAgent?: string;
    metadata?: any;
  }): Promise<void> {
    try {
      await AuditLog.create({
        userId: params.userId,
        performedBy: params.performedBy,
        action: params.action,
        entity: params.entity,
        entityId: params.entityId,
        oldValue: params.oldValue,
        newValue: params.newValue,
        ipAddress: params.ipAddress,
        userAgent: params.userAgent,
        metadata: params.metadata
      });
      
      logger.info('Audit log created', {
        action: params.action,
        entity: params.entity,
        userId: params.userId
      });
      
    } catch (error) {
      logger.error('Failed to create audit log', { error, params });
      // Don't throw - audit logging failure shouldn't break the main flow
    }
  }
  
  /**
   * Get audit trail for a user
   */
  async getUserAuditTrail(userId: string, limit: number = 50) {
    return AuditLog.find({ userId })
      .sort({ createdAt: -1 })
      .limit(limit)
      .populate('performedBy', 'fullName email');
  }
  
  /**
   * Get audit trail for an entity
   */
  async getEntityAuditTrail(entity: string, entityId: string) {
    return AuditLog.find({ entity, entityId })
      .sort({ createdAt: -1 })
      .populate('userId', 'fullName email')
      .populate('performedBy', 'fullName email');
  }
  
  /**
   * Export audit logs for compliance (GDPR, etc.)
   */
  async exportAuditLogs(filters: {
    startDate: Date;
    endDate: Date;
    userId?: string;
    actions?: AuditAction[];
  }) {
    const query: any = {
      createdAt: {
        $gte: filters.startDate,
        $lte: filters.endDate
      }
    };
    
    if (filters.userId) query.userId = filters.userId;
    if (filters.actions) query.action = { $in: filters.actions };
    
    return AuditLog.find(query)
      .sort({ createdAt: 1 })
      .lean();
  }
}


export const auditService = new AuditService();
5.8 GDPR Compliance Features
// src/services/gdprService.ts
import User from '../models/User';
import Loan from '../models/Loan';
import Installment from '../models/Installment';
import PaymentTransaction from '../models/PaymentTransaction';
import EmailLog from '../models/EmailLog';
import AuditLog from '../models/AuditLog';
import { auditService } from './auditService';


class GDPRService {
  
  /**
   * Export all user data (Right to Data Portability)
   */
  async exportUserData(userId: string): Promise<any> {
    const [user, loans, installments, payments, emails, auditLogs] = await Promise.all([
      User.findById(userId).select('-passwordHash'),
      Loan.find({ userId }),
      Installment.find({ userId }),
      PaymentTransaction.find({ userId }),
      EmailLog.find({ userId }),
      AuditLog.find({ userId }).limit(1000)
    ]);
    
    return {
      personal_information: user,
      loans: loans,
      installments: installments,
      payments: payments,
      emails: emails,
      audit_trail: auditLogs,
      export_date: new Date().toISOString(),
      format_version: '1.0'
    };
  }
  
  /**
   * Anonymize user data (Right to be Forgotten)
   * Note: For financial records, we may need to retain some data for legal reasons
   */
  async anonymizeUserData(userId: string, requestedBy: string): Promise<void> {
    const user = await User.findById(userId);
    if (!user) throw new Error('User not found');
    
    // Check if user has active loans - may not be able to delete
    const activeLoans = await Loan.countDocuments({
      userId,
      status: 'ACTIVE'
    });
    
    if (activeLoans > 0) {
      throw new Error('Cannot anonymize user with active loans. Please settle all loans first.');
    }
    
    // Anonymize personal data
    user.fullName = `ANONYMIZED_${userId.substring(0, 8)}`;
    user.email = `anonymized_${userId}@deleted.local`;
    user.phone = '0000000000';
    user.address = 'ANONYMIZED';
    user.cnicHash = 'ANONYMIZED';
    await user.save();
    
    // Log the anonymization
    await auditService.log({
      userId,
      performedBy: requestedBy,
      action: 'USER_ANONYMIZED' as any,
      entity: 'User',
      entityId: userId,
      metadata: { reason: 'GDPR Right to be Forgotten' }
    });
  }
  
  /**
   * Generate privacy policy compliance report
   */
  async generateComplianceReport(startDate: Date, endDate: Date) {
    const [
      totalUsers,
      dataExportRequests,
      anonymizationRequests,
      aiCallsCount
    ] = await Promise.all([
      User.countDocuments({
        createdAt: { $gte: startDate, $lte: endDate }
      }),
      AuditLog.countDocuments({
        action: 'DATA_EXPORT_REQUEST' as any,
        createdAt: { $gte: startDate, $lte: endDate }
      }),
      AuditLog.countDocuments({
        action: 'USER_ANONYMIZED' as any,
        createdAt: { $gte: startDate, $lte: endDate }
      }),
      AuditLog.countDocuments({
        action: 'AI_API_CALL' as any,
        createdAt: { $gte: startDate, $lte: endDate }
      })
    ]);
    
    return {
      period: { startDate, endDate },
      users: { total: totalUsers },
      gdpr_requests: {
        data_exports: dataExportRequests,
        anonymizations: anonymizationRequests
      },
      ai_usage: {
        total_calls: aiCallsCount,
        pii_protection_enabled: true
      }
    };
  }
}


export const gdprService = new GDPRService();
________________


6. DEPLOYMENT PLAN
6.1 Environment Configuration
# .env.production


# Server
NODE_ENV=production
PORT=5000
API_URL=https://api.yourdomain.com


# Frontend
FRONTEND_URL=https://app.yourdomain.com


# Database
MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/mlms?retryWrites=true&w=majority


# JWT
JWT_ACCESS_SECRET=<strong-random-secret-256-bits>
JWT_REFRESH_SECRET=<different-strong-random-secret>


# Encryption
ENCRYPTION_SECRET=<strong-encryption-key-for-field-level-encryption>


# Google Gemini
GEMINI_API_KEY=<your-gemini-api-key>


# Stripe
STRIPE_SECRET_KEY=sk_live_xxxxx
STRIPE_PUBLISHABLE_KEY=pk_live_xxxxx
STRIPE_WEBHOOK_SECRET=whsec_xxxxx


# Email (SendGrid)
SENDGRID_API_KEY=SG.xxxxx
EMAIL_FROM_ADDRESS=noreply@yourdomain.com


# Redis (for rate limiting)
REDIS_URL=redis://redis-server:6379


# Logging
LOG_LEVEL=info


# Cron Jobs
ENABLE_CRON_JOBS=true
MONTHLY_INSTALLMENT_CRON=0 2 1 * *
OVERDUE_CHECKER_CRON=0 3 * * *
6.2 Backend Deployment (Node.js/Express)
Platform: Render / Railway / AWS EC2
Dockerfile:
# Dockerfile
FROM node:18-alpine


WORKDIR /app


# Install dependencies
COPY package*.json ./
RUN npm ci --only=production


# Copy source code
COPY . .


# Build TypeScript
RUN npm run build


# Expose port
EXPOSE 5000


# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD node healthcheck.js || exit 1


# Start server
CMD ["node", "dist/server.js"]
package.json scripts:
{
  "scripts": {
    "dev": "nodemon src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "test": "jest",
    "lint": "eslint src/**/*.ts",
    "migrate": "node dist/scripts/migrate.js"
  }
}
Deployment Steps (Render):
1. Create New Web Service
   * Connect GitHub repository
   * Set branch to main
   * Build command: npm install && npm run build
   * Start command: npm start
2. Configure Environment Variables
   * Add all production environment variables
   * Enable "Auto-Deploy" for main branch
3. Set Up MongoDB Atlas
   * Create cluster
   * Whitelist Render's IP addresses
   * Copy connection string to MONGODB_URI
4. Configure Stripe Webhooks
   * Get public URL from Render (e.g., https://mlms-api.onrender.com)
   * In Stripe Dashboard → Webhooks → Add endpoint
   * URL: https://mlms-api.onrender.com/api/payments/stripe/webhook
   * Events: checkout.session.completed, payment_intent.succeeded, payment_intent.payment_failed
   * Copy webhook signing secret to STRIPE_WEBHOOK_SECRET
5. Health Check Endpoint
// src/routes/health.routes.ts
import express from 'express';
import mongoose from 'mongoose';
import { geminiClient } from '../ai/geminiClient';


const router = express.Router();


router.get('/health', async (req, res) => {
  const health = {
    uptime: process.uptime(),
    timestamp: Date.now(),
    status: 'OK',
    checks: {
      database: 'UNKNOWN',
      gemini: 'UNKNOWN'
    }
  };
  
  try {
    // Check MongoDB
    if (mongoose.connection.readyState === 1) {
      health.checks.database = 'CONNECTED';
    } else {
      health.checks.database = 'DISCONNECTED';
      health.status = 'DEGRADED';
    }
    
    // Check Gemini API
    const geminiHealthy = await geminiClient.healthCheck();
    health.checks.gemini = geminiHealthy ? 'CONNECTED' : 'DISCONNECTED';
    
    if (!geminiHealthy) {
      health.status = 'DEGRADED';
    }
    
    res.status(health.status === 'OK' ? 200 : 503).json(health);
    
  } catch (error) {
    health.status = 'ERROR';
    res.status(503).json(health);
  }
});


export default router;
6.3 Frontend Deployment (Next.js)
Platform: Vercel (Recommended)
Deployment Steps:
1. Connect Repository
   * Import project from GitHub
   * Framework Preset: Next.js
   * Root Directory: ./frontend
2. Environment Variables
# Production Environment Variables (Vercel)
NEXT_PUBLIC_API_URL=https://mlms-api.onrender.com/api
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_live_xxxxx
3. Build Settings
   * Build Command: npm run build
   * Output Directory: .next
   * Install Command: npm install
4. Custom Domain
   * Add custom domain (e.g., app.yourdomain.com)
   * Configure DNS records
   * Enable HTTPS (automatic with Vercel)
5. Performance Optimizations
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  
  // Image optimization
  images: {
    domains: ['yourdomain.com'],
    formats: ['image/avif', 'image/webp']
  },
  
  // Compression
  compress: true,
  
  // Security headers
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'X-Frame-Options',
            value: 'DENY'
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff'
          },
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin'
          }
        ]
      }
    ];
  }
};


module.exports = nextConfig;
6.4 Cron Jobs Configuration
Option 1: Same Server (Node-Cron)
// src/cron/index.ts
import cron from 'node-cron';
import { monthlyInstallmentsJob } from './monthlyInstallments';
import { overdueCheckerJob } from './overdueChecker';
import { defaultFlagJob } from './defaultFlagger';
import logger from '../utils/logger';
import { config } from '../config/environment';


export const initializeCronJobs = () => {
  if (!config.cron.enabled) {
    logger.info('Cron jobs disabled');
    return;
  }
  
  // Monthly installment generation: 1st of every month at 2 AM
  cron.schedule('0 2 1 * *', async () => {
    logger.info('Running monthly installments job');
    try {
      await monthlyInstallmentsJob();
    } catch (error) {
      logger.error('Monthly installments job failed', { error });
    }
  }, {
    timezone: 'Asia/Karachi'
  });
  
  // Overdue checker: Every day at 3 AM
  cron.schedule('0 3 * * *', async () => {
    logger.info('Running overdue checker job');
    try {
      await overdueCheckerJob();
    } catch (error) {
      logger.error('Overdue checker job failed', { error });
    }
  }, {
    timezone: 'Asia/Karachi'
  });
  
  // Default flagging: Every day at 4 AM
  cron.schedule('0 4 * * *', async () => {
    logger.info('Running default flagging job');
    try {
      await defaultFlagJob();
    } catch (error) {
      logger.error('Default flagging job failed', { error });
    }
  }, {
    timezone: 'Asia/Karachi'
  });
  
  logger.info('Cron jobs initialized');
};
Option 2: External Scheduler (AWS EventBridge / Render Cron Jobs)
For Render, create separate cron job services:
# render.yaml
services:
  - type: web
    name: mlms-api
    env: node
    plan: starter
    buildCommand: npm install && npm run build
    startCommand: npm start
    envVars:
      - key: NODE_ENV
        value: production
  
  - type: cron
    name: monthly-installments
    env: node
    schedule: "0 2 1 * *"
    buildCommand: npm install && npm run build
    startCommand: node dist/cron/monthlyInstallments.js
    
  - type: cron
    name: overdue-checker
    env: node
    schedule: "0 3 * * *"
    buildCommand: npm install && npm run build
    startCommand: node dist/cron/overdueChecker.js
6.5 CI/CD Pipeline
GitHub Actions Workflow:
# .github/workflows/deploy.yml
name: Deploy to Production


on:
  push:
    branches: [main]
  pull_request:
    branches: [main]


jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint
      
      - name: Run tests
        run: npm test
        env:
          NODE_ENV: test
          MONGODB_URI: ${{ secrets.TEST_MONGODB_URI }}
  
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to Render
        run: |
          curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK }}
      
      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Deployment to production completed'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        if: always()
6.6 Monitoring & Logging
Logging Setup (Winston):
// src/utils/logger.ts
import winston from 'winston';
import { config } from '../config/environment';


const logger = winston.createLogger({
  level: config.log.level,
  format: winston.
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'mlms-api' },
  transports: [
    // Write all logs to console
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    
    // Write error logs to file
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    
    // Write all logs to file
    new winston.transports.File({
      filename: 'logs/combined.log',
      maxsize: 5242880,
      maxFiles: 5
    })
  ]
});


// If production, also send to external logging service
if (config.env === 'production') {
  // Example: Send to LogDNA, Datadog, etc.
  // logger.add(new LogDNATransport({ key: config.logdna.key }));
}


export default logger;
Error Tracking (Sentry):
// src/config/sentry.ts
import * as Sentry from '@sentry/node';
import { config } from './environment';


export const initializeSentry = (app: any) => {
  if (config.env === 'production' && config.sentry.dsn) {
    Sentry.init({
      dsn: config.sentry.dsn,
      environment: config.env,
      tracesSampleRate: 0.1,
      
      // Capture unhandled promise rejections
      integrations: [
        new Sentry.Integrations.Http({ tracing: true }),
        new Sentry.Integrations.Express({ app })
      ]
    });
    
    // Request handler must be first
    app.use(Sentry.Handlers.requestHandler());
    app.use(Sentry.Handlers.tracingHandler());
  }
};


export const captureException = (error: Error, context?: any) => {
  if (config.env === 'production') {
    Sentry.captureException(error, { extra: context });
  }
};
Application Performance Monitoring:
// src/middlewares/requestLogger.middleware.ts
import { Request, Response, NextFunction } from 'express';
import logger from '../utils/logger';


export const requestLogger = (req: Request, res: Response, next: NextFunction) => {
  const startTime = Date.now();
  
  // Log request
  logger.info('Incoming request', {
    method: req.method,
    url: req.url,
    ip: req.ip,
    userAgent: req.get('user-agent')
  });
  
  // Override res.json to log response
  const originalJson = res.json.bind(res);
  res.json = function(body: any) {
    const duration = Date.now() - startTime;
    
    logger.info('Outgoing response', {
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: `${duration}ms`
    });
    
    return originalJson(body);
  };
  
  next();
};
6.7 Database Backup Strategy
MongoDB Atlas Automated Backups:
// src/scripts/backup.ts
import { exec } from 'child_process';
import { promisify } from 'util';
import { config } from '../config/environment';
import logger from '../utils/logger';


const execAsync = promisify(exec);


/**
 * Manual backup script (for local testing)
 * In production, use MongoDB Atlas automated backups
 */
export const createBackup = async (): Promise<void> => {
  try {
    const timestamp = new Date().toISOString().replace(/:/g, '-');
    const backupPath = `./backups/backup-${timestamp}`;
    
    logger.info('Starting database backup', { backupPath });
    
    // Use mongodump
    const command = `mongodump --uri="${config.mongodb.uri}" --out=${backupPath}`;
    await execAsync(command);
    
    logger.info('Backup completed successfully', { backupPath });
    
    // Optional: Upload to S3 or cloud storage
    // await uploadToS3(backupPath);
    
  } catch (error) {
    logger.error('Backup failed', { error });
    throw error;
  }
};


/**
 * Restore from backup
 */
export const restoreBackup = async (backupPath: string): Promise<void> => {
  try {
    logger.info('Starting database restore', { backupPath });
    
    const command = `mongorestore --uri="${config.mongodb.uri}" ${backupPath}`;
    await execAsync(command);
    
    logger.info('Restore completed successfully');
    
  } catch (error) {
    logger.error('Restore failed', { error });
    throw error;
  }
};
MongoDB Atlas Configuration:
1. Enable Continuous Backups
   * In Atlas Console → Clusters → Backup
   * Enable "Continuous Cloud Backup"
   * Configure retention period (e.g., 7 days)
2. Point-in-Time Recovery
   * Available for last 24 hours
   * Can restore to any second within retention window
3. Scheduled Snapshots
   * Daily snapshots at configured time
   * Monthly snapshots retained for compliance
6.8 Scaling Strategy
Horizontal Scaling (Multiple Instances):
// src/server.ts
import cluster from 'cluster';
import os from 'os';
import { config } from './config/environment';
import logger from './utils/logger';


const numCPUs = os.cpus().length;


if (config.env === 'production' && config.clustering.enabled && cluster.isMaster) {
  logger.info(`Master process ${process.pid} is running`);
  
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  cluster.on('exit', (worker, code, signal) => {
    logger.warn(`Worker ${worker.process.pid} died. Spawning new worker...`);
    cluster.fork();
  });
  
} else {
  // Worker processes
  import('./app').then(({ default: app }) => {
    const PORT = config.port || 5000;
    
    app.listen(PORT, () => {
      logger.info(`Worker ${process.pid} started on port ${PORT}`);
    });
  });
}
Load Balancer Configuration (Nginx):
# /etc/nginx/sites-available/mlms-api
upstream mlms_backend {
    least_conn;
    server backend1.yourdomain.com:5000 weight=1;
    server backend2.yourdomain.com:5000 weight=1;
    server backend3.yourdomain.com:5000 weight=1;
}


server {
    listen 80;
    server_name api.yourdomain.com;
    
    # Redirect to HTTPS
    return 301 https://$server_name$request_uri;
}


server {
    listen 443 ssl http2;
    server_name api.yourdomain.com;
    
    # SSL Configuration
    ssl_certificate /etc/letsencrypt/live/api.yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/api.yourdomain.com/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    
    # Security Headers
    add_header X-Frame-Options "DENY" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Request size limits
    client_max_body_size 10M;
    
    # Proxy settings
    location / {
        proxy_pass http://mlms_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
    
    # Health check endpoint
    location /health {
        proxy_pass http://mlms_backend/api/health;
        access_log off;
    }
}
Database Connection Pooling:
// src/config/database.ts
import mongoose from 'mongoose';
import { config } from './environment';
import logger from '../utils/logger';


export const connectDatabase = async (): Promise<void> => {
  try {
    await mongoose.connect(config.mongodb.uri, {
      maxPoolSize: 50,        // Maximum connections in pool
      minPoolSize: 10,        // Minimum connections maintained
      socketTimeoutMS: 45000,
      serverSelectionTimeoutMS: 5000,
      family: 4               // Use IPv4
    });
    
    logger.info('MongoDB connected successfully');
    
    // Monitor connection events
    mongoose.connection.on('error', (err) => {
      logger.error('MongoDB connection error', { error: err });
    });
    
    mongoose.connection.on('disconnected', () => {
      logger.warn('MongoDB disconnected');
    });
    
    mongoose.connection.on('reconnected', () => {
      logger.info('MongoDB reconnected');
    });
    
  } catch (error) {
    logger.error('MongoDB connection failed', { error });
    process.exit(1);
  }
};


// Graceful shutdown
export const disconnectDatabase = async (): Promise<void> => {
  try {
    await mongoose.connection.close();
    logger.info('MongoDB connection closed');
  } catch (error) {
    logger.error('Error closing MongoDB connection', { error });
  }
};
6.9 Disaster Recovery Plan
Recovery Time Objective (RTO): 2 hours
Recovery Point Objective (RPO): 1 hour
Disaster Recovery Procedures:
# DISASTER RECOVERY RUNBOOK


## Scenario 1: Database Corruption/Loss


1. **Immediate Actions:**
   - Stop all write operations
   - Isolate affected database instance
   - Assess extent of damage


2. **Recovery Steps:**
   ```bash
   # Restore from latest Atlas snapshot
   # Via Atlas Console → Backups → Restore
   # Or via CLI:
   atlas backups snapshots restore <snapshotId> --clusterName mlms-cluster
3. Verification:
   * Run data integrity checks
   * Verify critical collections
   * Test application connectivity
4. Resume Operations:
   * Update DNS/connection strings if needed
   * Enable write operations
   * Monitor for issues
Scenario 2: API Server Failure
1. Auto-Recovery (Load Balancer):
   * Load balancer detects failed instance
   * Routes traffic to healthy instances
   * Failed instance auto-restarts
2. Manual Intervention (if needed):
3. # SSH to server
4. ssh admin@api-server.yourdomain.com
5. 6. # Check logs
7. pm2 logs mlms-api --lines 100
8. 9. # Restart application
10. pm2 restart mlms-api
11. 12. # Or rebuild from scratch
13. git pull origin main
14. npm install
15. npm run build
16. pm2 restart mlms-api
Scenario 3: Stripe Webhook Failures
1. Detection:
   * Monitor webhook delivery failures in Stripe Dashboard
   * Check webhook endpoint health
2. Recovery:
3. # Replay failed webhooks via Stripe CLI
4. stripe events resend evt_xxxxx
5. 6. # Or bulk replay
7. stripe events list --limit 100 | jq -r '.data[].id' | xargs -I {} stripe events resend {}
8. Manual Reconciliation:
   * Query Stripe for payment status
   * Update database records accordingly
   * Send missed confirmation emails
Scenario 4: Gemini API Outage
1. Graceful Degradation:
   * System should continue operating without AI features
   * Risk calculations use cached values
   * New risk assessments queued for later
2. Recovery:
   * Monitor Gemini API status
   * Once restored, process queued requests
   * Re-calculate stale risk profiles
Emergency Contacts
* On-Call Engineer: +92-XXX-XXXXXXX
* Database Admin: +92-XXX-XXXXXXX
* DevOps Lead: +92-XXX-XXXXXXX
* Stripe Support: support@stripe.com
* Google Cloud Support: (via console)


### 6.10 Production Checklist


```markdown
# PRE-DEPLOYMENT CHECKLIST


## Security
- [ ] All environment variables configured
- [ ] Strong JWT secrets generated (256-bit)
- [ ] Encryption keys generated and secured
- [ ] HTTPS enabled with valid SSL certificate
- [ ] CORS configured with production domains only
- [ ] Rate limiting enabled on all endpoints
- [ ] Helmet security headers configured
- [ ] Input validation on all endpoints
- [ ] SQL injection protection (N/A - using MongoDB)
- [ ] XSS protection enabled
- [ ] CSRF protection implemented


## Database
- [ ] MongoDB Atlas cluster created
- [ ] IP whitelist configured
- [ ] Database user created with minimal permissions
- [ ] Indexes created on all required fields
- [ ] Automated backups enabled (daily + continuous)
- [ ] Point-in-time recovery enabled
- [ ] Connection pooling configured
- [ ] Database monitoring enabled


## APIs & Integrations
- [ ] Gemini API key valid and working
- [ ] Stripe account configured (live mode)
- [ ] Stripe webhook endpoint configured
- [ ] Stripe webhook secret configured
- [ ] SendGrid/Email provider configured
- [ ] Email templates tested
- [ ] All API keys rotated from development


## Application
- [ ] All dependencies updated to stable versions
- [ ] No console.log statements in production code
- [ ] Error handling implemented everywhere
- [ ] Graceful shutdown handlers configured
- [ ] Health check endpoint working
- [ ] Logging configured (Winston + external service)
- [ ] Error tracking configured (Sentry)
- [ ] Cron jobs scheduled and tested
- [ ] PII anonymization verified for AI calls
- [ ] Audit logging enabled


## Frontend
- [ ] Environment variables configured
- [ ] API URLs pointing to production
- [ ] Analytics configured (Google Analytics, etc.)
- [ ] Error boundary implemented
- [ ] Loading states for all async operations
- [ ] Toast notifications configured
- [ ] Route protection working
- [ ] Build optimized and minified
- [ ] Images optimized
- [ ] Lighthouse score > 90


## Testing
- [ ] Unit tests passing (>80% coverage)
- [ ] Integration tests passing
- [ ] End-to-end tests passing
- [ ] Load testing completed
- [ ] Security scanning completed (OWASP ZAP)
- [ ] Manual QA testing completed


## Documentation
- [ ] API documentation complete (Swagger/Postman)
- [ ] README updated with deployment instructions
- [ ] Environment variables documented
- [ ] Architecture diagrams created
- [ ] Runbooks created for common issues
- [ ] Disaster recovery plan documented


## Monitoring & Alerting
- [ ] Application monitoring configured
- [ ] Database monitoring configured
- [ ] Uptime monitoring configured (UptimeRobot, etc.)
- [ ] Error rate alerts configured
- [ ] Performance alerts configured
- [ ] Disk space alerts configured
- [ ] SSL certificate expiry alerts configured


## Compliance
- [ ] Privacy policy created and deployed
- [ ] Terms of service created and deployed
- [ ] GDPR compliance verified
- [ ] Data retention policy defined
- [ ] User consent mechanisms implemented
- [ ] Data export functionality working
- [ ] Data deletion functionality working


## Performance
- [ ] Database queries optimized
- [ ] API response times < 500ms
- [ ] Frontend load time < 3 seconds
- [ ] Images lazy-loaded
- [ ] CDN configured for static assets
- [ ] Gzip compression enabled
- [ ] Connection pooling optimized


## Deployment
- [ ] CI/CD pipeline configured
- [ ] Staging environment tested
- [ ] Database migrations tested
- [ ] Rollback plan documented
- [ ] Zero-downtime deployment strategy
- [ ] DNS records configured
- [ ] Load balancer configured (if applicable)


## Post-Deployment
- [ ] Smoke tests passing in production
- [ ] Monitor logs for errors (first 24 hours)
- [ ] Verify all cron jobs executing
- [ ] Verify webhooks receiving events
- [ ] Verify emails sending successfully
- [ ] User acceptance testing
- [ ] Performance monitoring active
________________


7. APPENDIX
7.1 Key Technologies Summary
Component
	Technology
	Version
	Purpose
	Backend Runtime
	Node.js
	18.x
	Server-side JavaScript
	Backend Framework
	Express.js
	4.18+
	REST API framework
	Database
	MongoDB
	6.0+
	Document database
	ODM
	Mongoose
	7.x
	MongoDB object modeling
	AI Model
	Google Gemini
	1.5-flash
	Risk scoring & predictions
	Payment Gateway
	Stripe
	Latest
	Payment processing
	Email Service
	SendGrid
	Latest
	Transactional emails
	Frontend Framework
	Next.js
	14.x
	React framework
	UI Components
	shadcn/ui
	Latest
	Component library
	Styling
	Tailwind CSS
	3.x
	Utility-first CSS
	State Management
	React Query
	5.x
	Server state management
	Authentication
	JWT
	-
	Token-based auth
	Validation
	Zod
	Latest
	Schema validation
	Logging
	Winston
	Latest
	Application logging
	Task Scheduling
	node-cron
	Latest
	Cron job management
	7.2 API Response Format Standards
Success Response:
{
  "success": true,
  "message": "Operation completed successfully",
  "data": {
    // Response data here
  }
}
Error Response:
{
  "success": false,
  "message": "Error message here",
  "errors": [
    {
      "field": "email",
      "message": "Invalid email format"
    }
  ]
}
Pagination Response:
{
  "success": true,
  "data": {
    "items": [],
    "pagination": {
      "currentPage": 1,
      "totalPages": 10,
      "totalCount": 100,
      "limit": 10
    }
  }
}
7.3 HTTP Status Codes Used
* 200 OK: Successful GET, PUT, PATCH requests
* 201 Created: Successful POST requests creating resources
* 204 No Content: Successful DELETE requests
* 400 Bad Request: Invalid input, validation errors
* 401 Unauthorized: Missing or invalid authentication
* 403 Forbidden: Authenticated but insufficient permissions
* 404 Not Found: Resource not found
* 409 Conflict: Duplicate resource (e.g., email already exists)
* 429 Too Many Requests: Rate limit exceeded
* 500 Internal Server Error: Unexpected server error
* 503 Service Unavailable: External service down (Stripe, Gemini)
________________


CONCLUSION
This technical documentation provides a complete, production-ready specification for the AI-Enhanced Microfinance Loan Management System. The system is designed with:
* Security-first approach: JWT authentication, field-level encryption, PII protection
* AI Integration: Google Gemini for risk scoring with privacy-preserving data anonymization
* Automated Workflows: Monthly billing, overdue management, default detection
* Payment Processing: Secure Stripe integration with webhook handling
* Scalability: Horizontal scaling, connection pooling, load balancing
* Monitoring: Comprehensive logging, error tracking, audit trails
* Compliance: GDPR-ready, audit logging, data export/deletion
Next Steps for Implementation:
1. Set up development environment with all required services
2. Implement backend API following the specifications
3. Integrate Google Gemini with proper PII protection
4. Build frontend with Next.js and connect to backend
5. Test thoroughly (unit, integration, E2E)
6. Deploy to staging environment
7. Conduct security audit
8. Deploy to production following the checklist
9. Monitor and iterate based on user feedback
This system is ready for a development team to implement directly with all technical decisions already made and documented.